#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_14__   TYPE_5__ ;
typedef  struct TYPE_13__   TYPE_1__ ;

/* Type definitions */
typedef  enum pragma_context { ____Placeholder_pragma_context } pragma_context ;
struct TYPE_13__ {int error; } ;
typedef  TYPE_1__ c_parser ;
struct TYPE_14__ {unsigned int pragma_kind; } ;

/* Variables and functions */
 int /*<<< orphan*/  CPP_PRAGMA_EOL ; 
 unsigned int PRAGMA_FIRST_EXTERNAL ; 
#define  PRAGMA_GCC_PCH_PREPROCESS 132 
 unsigned int PRAGMA_NONE ; 
#define  PRAGMA_OMP_BARRIER 131 
#define  PRAGMA_OMP_FLUSH 130 
#define  PRAGMA_OMP_SECTION 129 
#define  PRAGMA_OMP_THREADPRIVATE 128 
 int /*<<< orphan*/  c_invoke_pragma_handler (unsigned int) ; 
 int /*<<< orphan*/  c_parser_consume_pragma (TYPE_1__*) ; 
 int /*<<< orphan*/  c_parser_error (TYPE_1__*,char*) ; 
 int /*<<< orphan*/  c_parser_omp_barrier (TYPE_1__*) ; 
 int /*<<< orphan*/  c_parser_omp_construct (TYPE_1__*) ; 
 int /*<<< orphan*/  c_parser_omp_flush (TYPE_1__*) ; 
 int /*<<< orphan*/  c_parser_omp_threadprivate (TYPE_1__*) ; 
 TYPE_5__* c_parser_peek_token (TYPE_1__*) ; 
 int /*<<< orphan*/  c_parser_skip_to_pragma_eol (TYPE_1__*) ; 
 int /*<<< orphan*/  c_parser_skip_until_found (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  error (char*) ; 
 int /*<<< orphan*/  gcc_assert (int) ; 
 int pragma_compound ; 
 int pragma_external ; 
 int pragma_stmt ; 

__attribute__((used)) static bool
c_parser_pragma (c_parser *parser, enum pragma_context context)
{
  unsigned int id;

  id = c_parser_peek_token (parser)->pragma_kind;
  gcc_assert (id != PRAGMA_NONE);

  switch (id)
    {
    case PRAGMA_OMP_BARRIER:
      if (context != pragma_compound)
	{
	  if (context == pragma_stmt)
	    c_parser_error (parser, "%<#pragma omp barrier%> may only be "
			    "used in compound statements");
	  goto bad_stmt;
	}
      c_parser_omp_barrier (parser);
      return false;

    case PRAGMA_OMP_FLUSH:
      if (context != pragma_compound)
	{
	  if (context == pragma_stmt)
	    c_parser_error (parser, "%<#pragma omp flush%> may only be "
			    "used in compound statements");
	  goto bad_stmt;
	}
      c_parser_omp_flush (parser);
      return false;

    case PRAGMA_OMP_THREADPRIVATE:
      c_parser_omp_threadprivate (parser);
      return false;

    case PRAGMA_OMP_SECTION:
      error ("%<#pragma omp section%> may only be used in "
	     "%<#pragma omp sections%> construct");
      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
      return false;

    case PRAGMA_GCC_PCH_PREPROCESS:
      c_parser_error (parser, "%<#pragma GCC pch_preprocess%> must be first");
      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
      return false;

    default:
      if (id < PRAGMA_FIRST_EXTERNAL)
	{
	  if (context == pragma_external)
	    {
	    bad_stmt:
	      c_parser_error (parser, "expected declaration specifiers");
	      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
	      return false;
	    }
	  c_parser_omp_construct (parser);
	  return true;
	}
      break;
    }

  c_parser_consume_pragma (parser);
  c_invoke_pragma_handler (id);

  /* Skip to EOL, but suppress any error message.  Those will have been 
     generated by the handler routine through calling error, as opposed
     to calling c_parser_error.  */
  parser->error = true;
  c_parser_skip_to_pragma_eol (parser);

  return false;
}