#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  rtx ;

/* Variables and functions */
 int /*<<< orphan*/  CPU_POWER4 ; 
 int /*<<< orphan*/  CPU_POWER5 ; 
 int /*<<< orphan*/  CPU_PPC603 ; 
 int /*<<< orphan*/  CPU_PPC604 ; 
 int /*<<< orphan*/  CPU_PPC604E ; 
 int /*<<< orphan*/  CPU_PPC620 ; 
 int /*<<< orphan*/  CPU_PPC630 ; 
 int /*<<< orphan*/  CPU_PPC7400 ; 
 int /*<<< orphan*/  CPU_PPC7450 ; 
 int /*<<< orphan*/  CPU_PPC750 ; 
 scalar_t__ GET_CODE (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  GET_MODE (int /*<<< orphan*/ ) ; 
 scalar_t__ GET_MODE_SIZE (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  INSN_CODE (int /*<<< orphan*/ ) ; 
 scalar_t__ MEM ; 
 int /*<<< orphan*/  PATTERN (int /*<<< orphan*/ ) ; 
 scalar_t__ REG_NOTE_KIND (int /*<<< orphan*/ ) ; 
 scalar_t__ SET ; 
 int /*<<< orphan*/  TARGET_POWER ; 
#define  TYPE_BRANCH 129 
 int TYPE_CMP ; 
 int TYPE_COMPARE ; 
 int TYPE_CR_LOGICAL ; 
 int TYPE_DELAYED_COMPARE ; 
 int TYPE_DELAYED_CR ; 
 int TYPE_FPCOMPARE ; 
 int TYPE_IMUL_COMPARE ; 
#define  TYPE_JMPREG 128 
 int TYPE_LMUL_COMPARE ; 
 int /*<<< orphan*/  XEXP (int /*<<< orphan*/ ,int) ; 
 int get_attr_type (int /*<<< orphan*/ ) ; 
 scalar_t__ recog_memoized (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  rs6000_cpu_attr ; 
 scalar_t__ rs6000_sched_groups ; 

__attribute__((used)) static int
rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)
{
  if (! recog_memoized (insn))
    return 0;

  if (REG_NOTE_KIND (link) != 0)
    return 0;

  if (REG_NOTE_KIND (link) == 0)
    {
      /* Data dependency; DEP_INSN writes a register that INSN reads
	 some cycles later.  */

      /* Separate a load from a narrower, dependent store.  */
      if (rs6000_sched_groups
	  && GET_CODE (PATTERN (insn)) == SET
	  && GET_CODE (PATTERN (dep_insn)) == SET
	  && GET_CODE (XEXP (PATTERN (insn), 1)) == MEM
	  && GET_CODE (XEXP (PATTERN (dep_insn), 0)) == MEM
	  && (GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (insn), 1)))
	      > GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (dep_insn), 0)))))
	return cost + 14;

      switch (get_attr_type (insn))
	{
	case TYPE_JMPREG:
	  /* Tell the first scheduling pass about the latency between
	     a mtctr and bctr (and mtlr and br/blr).  The first
	     scheduling pass will not know about this latency since
	     the mtctr instruction, which has the latency associated
	     to it, will be generated by reload.  */
	  return TARGET_POWER ? 5 : 4;
	case TYPE_BRANCH:
	  /* Leave some extra cycles between a compare and its
	     dependent branch, to inhibit expensive mispredicts.  */
	  if ((rs6000_cpu_attr == CPU_PPC603
	       || rs6000_cpu_attr == CPU_PPC604
	       || rs6000_cpu_attr == CPU_PPC604E
	       || rs6000_cpu_attr == CPU_PPC620
	       || rs6000_cpu_attr == CPU_PPC630
	       || rs6000_cpu_attr == CPU_PPC750
	       || rs6000_cpu_attr == CPU_PPC7400
	       || rs6000_cpu_attr == CPU_PPC7450
	       || rs6000_cpu_attr == CPU_POWER4
	       || rs6000_cpu_attr == CPU_POWER5)
	      && recog_memoized (dep_insn)
	      && (INSN_CODE (dep_insn) >= 0)
	      && (get_attr_type (dep_insn) == TYPE_CMP
		  || get_attr_type (dep_insn) == TYPE_COMPARE
		  || get_attr_type (dep_insn) == TYPE_DELAYED_COMPARE
		  || get_attr_type (dep_insn) == TYPE_IMUL_COMPARE
		  || get_attr_type (dep_insn) == TYPE_LMUL_COMPARE
		  || get_attr_type (dep_insn) == TYPE_FPCOMPARE
		  || get_attr_type (dep_insn) == TYPE_CR_LOGICAL
		  || get_attr_type (dep_insn) == TYPE_DELAYED_CR))
	    return cost + 2;
	default:
	  break;
	}
      /* Fall out to return default cost.  */
    }

  return cost;
}