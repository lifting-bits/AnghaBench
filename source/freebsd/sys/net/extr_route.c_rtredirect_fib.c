#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_6__   TYPE_3__ ;
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  u_int ;
struct sockaddr {int /*<<< orphan*/  sa_family; } ;
struct rtentry {int rt_flags; struct ifaddr* rt_ifa; int /*<<< orphan*/  rt_gateway; } ;
struct rt_addrinfo {int rti_flags; struct sockaddr** rti_info; struct ifaddr* rti_ifa; } ;
struct rib_head {int dummy; } ;
struct ifaddr {TYPE_1__* ifa_addr; } ;
typedef  int /*<<< orphan*/  info ;
typedef  int /*<<< orphan*/  caddr_t ;
struct TYPE_6__ {short rts_dynamic; short rts_newgateway; int /*<<< orphan*/  rts_badredirect; } ;
struct TYPE_5__ {int sa_len; } ;
struct TYPE_4__ {scalar_t__ sa_family; } ;

/* Variables and functions */
 scalar_t__ AF_LINK ; 
 int EAFNOSUPPORT ; 
 int EHOSTUNREACH ; 
 int EINVAL ; 
 int ENETUNREACH ; 
 int /*<<< orphan*/  NET_EPOCH_ASSERT () ; 
 int /*<<< orphan*/  RIB_WLOCK (struct rib_head*) ; 
 int /*<<< orphan*/  RIB_WUNLOCK (struct rib_head*) ; 
 size_t RTAX_AUTHOR ; 
 size_t RTAX_DST ; 
 size_t RTAX_GATEWAY ; 
 size_t RTAX_NETMASK ; 
 int /*<<< orphan*/  RTFREE_LOCKED (struct rtentry*) ; 
 int RTF_DONE ; 
 int RTF_DYNAMIC ; 
 int RTF_GATEWAY ; 
 int RTF_HOST ; 
 int RTF_MODIFIED ; 
 int /*<<< orphan*/  RTM_ADD ; 
 int /*<<< orphan*/  RTM_REDIRECT ; 
 int /*<<< orphan*/  RT_LOCK (struct rtentry*) ; 
 int /*<<< orphan*/  RT_UNLOCK (struct rtentry*) ; 
 TYPE_3__ V_rtstat ; 
 int /*<<< orphan*/  bzero (int /*<<< orphan*/ ,int) ; 
 scalar_t__ ifa_ifwithaddr_check (struct sockaddr*) ; 
 struct ifaddr* ifa_ifwithnet (struct sockaddr*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  ifa_ref (struct ifaddr*) ; 
 int /*<<< orphan*/  rt_key (struct rtentry*) ; 
 TYPE_2__* rt_mask (struct rtentry*) ; 
 int /*<<< orphan*/  rt_missmsg_fib (int /*<<< orphan*/ ,struct rt_addrinfo*,int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  rt_setgate (struct rtentry*,int /*<<< orphan*/ ,struct sockaddr*) ; 
 struct rib_head* rt_tables_get_rnh (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 struct rtentry* rtalloc1_fib (struct sockaddr*,int /*<<< orphan*/ ,unsigned long,int /*<<< orphan*/ ) ; 
 int rtrequest1_fib (int /*<<< orphan*/ ,struct rt_addrinfo*,struct rtentry**,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sa_equal (struct sockaddr*,int /*<<< orphan*/ ) ; 

void
rtredirect_fib(struct sockaddr *dst,
	struct sockaddr *gateway,
	struct sockaddr *netmask,
	int flags,
	struct sockaddr *src,
	u_int fibnum)
{
	struct rtentry *rt;
	int error = 0;
	short *stat = NULL;
	struct rt_addrinfo info;
	struct ifaddr *ifa;
	struct rib_head *rnh;

	NET_EPOCH_ASSERT();

	ifa = NULL;
	rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
	if (rnh == NULL) {
		error = EAFNOSUPPORT;
		goto out;
	}
	/* verify the gateway is directly reachable */
	if ((ifa = ifa_ifwithnet(gateway, 0, fibnum)) == NULL) {
		error = ENETUNREACH;
		goto out;
	}
	rt = rtalloc1_fib(dst, 0, 0UL, fibnum);	/* NB: rt is locked */
	/*
	 * If the redirect isn't from our current router for this dst,
	 * it's either old or wrong.  If it redirects us to ourselves,
	 * we have a routing loop, perhaps as a result of an interface
	 * going down recently.
	 */
	if (!(flags & RTF_DONE) && rt) {
		if (!sa_equal(src, rt->rt_gateway)) {
			error = EINVAL;
			goto done;
		}
		if (rt->rt_ifa != ifa && ifa->ifa_addr->sa_family != AF_LINK) {
			error = EINVAL;
			goto done;
		}
	}
	if ((flags & RTF_GATEWAY) && ifa_ifwithaddr_check(gateway)) {
		error = EHOSTUNREACH;
		goto done;
	}
	/*
	 * Create a new entry if we just got back a wildcard entry
	 * or the lookup failed.  This is necessary for hosts
	 * which use routing redirects generated by smart gateways
	 * to dynamically build the routing tables.
	 */
	if (rt == NULL || (rt_mask(rt) && rt_mask(rt)->sa_len < 2))
		goto create;
	/*
	 * Don't listen to the redirect if it's
	 * for a route to an interface.
	 */
	if (rt->rt_flags & RTF_GATEWAY) {
		if (((rt->rt_flags & RTF_HOST) == 0) && (flags & RTF_HOST)) {
			/*
			 * Changing from route to net => route to host.
			 * Create new route, rather than smashing route to net.
			 */
		create:
			if (rt != NULL)
				RTFREE_LOCKED(rt);
		
			flags |= RTF_DYNAMIC;
			bzero((caddr_t)&info, sizeof(info));
			info.rti_info[RTAX_DST] = dst;
			info.rti_info[RTAX_GATEWAY] = gateway;
			info.rti_info[RTAX_NETMASK] = netmask;
			ifa_ref(ifa);
			info.rti_ifa = ifa;
			info.rti_flags = flags;
			error = rtrequest1_fib(RTM_ADD, &info, &rt, fibnum);
			if (rt != NULL) {
				RT_LOCK(rt);
				flags = rt->rt_flags;
			}
			
			stat = &V_rtstat.rts_dynamic;
		} else {

			/*
			 * Smash the current notion of the gateway to
			 * this destination.  Should check about netmask!!!
			 */
			if ((flags & RTF_GATEWAY) == 0)
				rt->rt_flags &= ~RTF_GATEWAY;
			rt->rt_flags |= RTF_MODIFIED;
			flags |= RTF_MODIFIED;
			stat = &V_rtstat.rts_newgateway;
			/*
			 * add the key and gateway (in one malloc'd chunk).
			 */
			RT_UNLOCK(rt);
			RIB_WLOCK(rnh);
			RT_LOCK(rt);
			rt_setgate(rt, rt_key(rt), gateway);
			RIB_WUNLOCK(rnh);
		}
	} else
		error = EHOSTUNREACH;
done:
	if (rt)
		RTFREE_LOCKED(rt);
 out:
	if (error)
		V_rtstat.rts_badredirect++;
	else if (stat != NULL)
		(*stat)++;
	bzero((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = dst;
	info.rti_info[RTAX_GATEWAY] = gateway;
	info.rti_info[RTAX_NETMASK] = netmask;
	info.rti_info[RTAX_AUTHOR] = src;
	rt_missmsg_fib(RTM_REDIRECT, &info, flags, error, fibnum);
}