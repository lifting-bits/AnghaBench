#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int u_char ;
struct ppc_data {scalar_t__ (* ppc_intr_hook ) (int /*<<< orphan*/ ) ;int ppc_mode; int ppc_irqstat; int ppc_avm; scalar_t__ ppc_dmastat; int /*<<< orphan*/  (* ppc_dmadone ) (struct ppc_data*) ;int /*<<< orphan*/  ppc_intr_arg; } ;

/* Variables and functions */
 int IRQENABLE ; 
 int PPB_ECP ; 
 scalar_t__ PPC_DMA_COMPLETE ; 
 scalar_t__ PPC_DMA_STARTED ; 
 int PPC_ENABLE_DMA ; 
 int PPC_IRQ_DMA ; 
 int PPC_IRQ_FIFO ; 
 int PPC_IRQ_nFAULT ; 
 int /*<<< orphan*/  PPC_LOCK (struct ppc_data*) ; 
 int PPC_SERVICE_INTR ; 
 int /*<<< orphan*/  PPC_UNLOCK (struct ppc_data*) ; 
 int PPC_nFAULT_INTR ; 
 int nFAULT ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int r_ctr (struct ppc_data*) ; 
 int r_ecr (struct ppc_data*) ; 
 int r_str (struct ppc_data*) ; 
 scalar_t__ stub1 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stub2 (struct ppc_data*) ; 
 int /*<<< orphan*/  w_ecr (struct ppc_data*,int) ; 
 int /*<<< orphan*/  wakeup (struct ppc_data*) ; 

__attribute__((used)) static void
ppcintr(void *arg)
{
	struct ppc_data *ppc = arg;
	u_char ctr, ecr, str;

	/*
	 * If we have any child interrupt handlers registered, let
	 * them handle this interrupt.
	 *
	 * XXX: If DMA is in progress should we just complete that w/o
	 * doing this?
	 */
	PPC_LOCK(ppc);
	if (ppc->ppc_intr_hook != NULL &&
	    ppc->ppc_intr_hook(ppc->ppc_intr_arg) == 0) {
		PPC_UNLOCK(ppc);
		return;
	}

	str = r_str(ppc);
	ctr = r_ctr(ppc);
	ecr = r_ecr(ppc);

#if defined(PPC_DEBUG) && PPC_DEBUG > 1
		printf("![%x/%x/%x]", ctr, ecr, str);
#endif

	/* don't use ecp mode with IRQENABLE set */
	if (ctr & IRQENABLE) {
		PPC_UNLOCK(ppc);
		return;
	}

	/* interrupts are generated by nFault signal
	 * only in ECP mode */
	if ((str & nFAULT) && (ppc->ppc_mode & PPB_ECP)) {
		/* check if ppc driver has programmed the
		 * nFault interrupt */
		if  (ppc->ppc_irqstat & PPC_IRQ_nFAULT) {

			w_ecr(ppc, ecr | PPC_nFAULT_INTR);
			ppc->ppc_irqstat &= ~PPC_IRQ_nFAULT;
		} else {
			/* shall be handled by underlying layers XXX */
			PPC_UNLOCK(ppc);
			return;
		}
	}

	if (ppc->ppc_irqstat & PPC_IRQ_DMA) {
		/* disable interrupts (should be done by hardware though) */
		w_ecr(ppc, ecr | PPC_SERVICE_INTR);
		ppc->ppc_irqstat &= ~PPC_IRQ_DMA;
		ecr = r_ecr(ppc);

		/* check if DMA completed */
		if ((ppc->ppc_avm & PPB_ECP) && (ecr & PPC_ENABLE_DMA)) {
#ifdef PPC_DEBUG
			printf("a");
#endif
			/* stop DMA */
			w_ecr(ppc, ecr & ~PPC_ENABLE_DMA);
			ecr = r_ecr(ppc);

			if (ppc->ppc_dmastat == PPC_DMA_STARTED) {
#ifdef PPC_DEBUG
				printf("d");
#endif
				ppc->ppc_dmadone(ppc);
				ppc->ppc_dmastat = PPC_DMA_COMPLETE;

				/* wakeup the waiting process */
				wakeup(ppc);
			}
		}
	} else if (ppc->ppc_irqstat & PPC_IRQ_FIFO) {

		/* classic interrupt I/O */
		ppc->ppc_irqstat &= ~PPC_IRQ_FIFO;
	}
	PPC_UNLOCK(ppc);

	return;
}