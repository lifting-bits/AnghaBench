#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  FD_CLOEXEC ; 
 int /*<<< orphan*/  F_SETFD ; 
 int /*<<< orphan*/  MAP_PRIVATE ; 
 int O_CREAT ; 
 int O_EXCL ; 
 int O_RDONLY ; 
 int O_WRONLY ; 
 int PROT_READ ; 
 int PROT_WRITE ; 
 int R_OK ; 
 int /*<<< orphan*/  SEEK_END ; 
 int /*<<< orphan*/  SET4 (char* const,char,float,char,char) ; 
 unsigned int UPX2 ; 
 int X_OK ; 
 scalar_t__ access (char*,int) ; 
 int /*<<< orphan*/  close (int const) ; 
 int /*<<< orphan*/  execve (char*,char**,char**) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fcntl (int const,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int const getpid () ; 
 unsigned int lseek (int const,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 char* mmap (char*,unsigned int const,int,int /*<<< orphan*/ ,int const,int /*<<< orphan*/ ) ; 
 int open (char const*,int,int) ; 
 int /*<<< orphan*/  unlink (char const*) ; 
 char* upx_itoa (int const,char* const) ; 
 scalar_t__ write (int const,char* const,unsigned int const) ; 

__attribute__((used)) static int
#if (ACC_CC_GNUC >= 0x030300)
__attribute__((__noinline__, __used__, __stdcall__))
#endif
go_self(char const *tmpname, char *argv[], char *envp[])
{
    // Old FreeBSD does not have /proc/self, so use /proc/<pid> instead.

    // Open the temp file.
    int const fdi = open(tmpname, O_RDONLY, 0);

    if (0 <= fdi) {
        // 17 chars for "/proc/PPPPP/fd/XX" should be enough, but we
        // play safe in case there will be 32-bit pid_t at some time.
        //char procself_buf[17+1];
        char procself_buf[31+1];

        // Compute name of temp fdi.
        SET4(procself_buf + 0, '/', 'p', 'r', 'o');
        SET4(procself_buf + 4, 'c', '/',  0 ,  0 );
        {
            char *const procself = upx_itoa(getpid(), procself_buf + 6);
            SET4(procself, '/', 'f', 'd', '/');
            upx_itoa(fdi, procself + 4);
        }

        // Check for working /proc/self/fd/X by accessing the
        // temp file again, now via temp fdi.
        if (UPX2 == (unsigned) access(procself_buf, R_OK | X_OK)) {
            // Now it's safe to unlink the temp file (as it is still open).
            unlink(tmpname);
            // Set the file close-on-exec.
            fcntl(fdi, F_SETFD, FD_CLOEXEC);
            // Execute the original program via /proc/self/fd/X.
            execve(procself_buf, argv, envp);
            // NOTE: if we get here we've lost.

            // 2008-March: Ubuntu 7.10 linux-image-2.6.22-14.52-generic
            // and SuSE 10.3 have a patch to fs/dcache.c which causes
            // execve() [above] to fail with ENOENT.
            // Fedora kernel-2.6.22.14-72.fc6 omits the patch, and works:
// https://sourceforge.net/tracker/?func=detail&atid=102331&aid=1825006&group_id=2331

            // Now we must re-create the file; it was unlink()ed!
            // link(procself_buf, tmpname) gets EXDEV (cross-device link).
            // Luckily we still have an open fdi to the file.
            // Errors from {lseek, mmap, open, write} are all caught
            // by the one check on write().
            unsigned const lenf = lseek(fdi, 0, SEEK_END);
            char *const buf = mmap((char *)0, lenf, PROT_READ|PROT_WRITE,
                MAP_PRIVATE, fdi, 0);
            int const fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);
            if (lenf!=(unsigned)write(fdo, buf, lenf)) {
                exit(127);
            }
            close(fdo);
        }

        // The proc filesystem isn't working. No problem.
        close(fdi);
    }
    return fdi;
}