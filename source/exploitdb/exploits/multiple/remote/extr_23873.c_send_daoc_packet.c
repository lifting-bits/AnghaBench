#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_6__   TYPE_3__ ;
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
struct daoc_packet_header {int dummy; } ;
struct TYPE_5__ {int /*<<< orphan*/  data; void* command_id; } ;
struct TYPE_4__ {char ESC1; char ESC2; void* payload_size; } ;
struct daoc_packet {TYPE_2__ payload; TYPE_1__ header; } ;
struct TYPE_6__ {int /*<<< orphan*/  socket; scalar_t__ sym_key_set; } ;

/* Variables and functions */
 TYPE_3__ client_sock_state ; 
 int /*<<< orphan*/  free (struct daoc_packet*) ; 
 void* htons (int) ; 
 struct daoc_packet* malloc (int) ; 
 int /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,void*,int) ; 
 int send (int /*<<< orphan*/ ,struct daoc_packet*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  symcrypt_in_place (unsigned char*,int) ; 

int send_daoc_packet(int command_id, void *buff, int len)
{
    struct daoc_packet *mem;
    int retval;
    int payload_size;
    int total_size;

    payload_size = len + 2;  // includes command_id
    total_size = payload_size + sizeof(struct daoc_packet_header);
    mem = malloc(total_size);
    mem->header.ESC1 = '\x1b';
    mem->header.ESC2 = '\x1b';
    mem->header.payload_size = htons(payload_size);
    mem->payload.command_id = htons(command_id);
    memcpy(&mem->payload.data, buff, len);

    if (client_sock_state.sym_key_set)
        symcrypt_in_place((unsigned char *)&mem->payload, payload_size);

    retval = send(client_sock_state.socket, mem, total_size, 0);

    free(mem);
    return retval;
}