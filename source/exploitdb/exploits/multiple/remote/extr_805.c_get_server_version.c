#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct timeval {scalar_t__ tv_usec; int /*<<< orphan*/  tv_sec; } ;
struct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; int /*<<< orphan*/  sin_zero; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  linebuf ;
typedef  int /*<<< orphan*/  lastbuf ;
typedef  int /*<<< orphan*/  info_buf ;
typedef  int /*<<< orphan*/  fd_set ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 unsigned char* CHECKELOG ; 
 int EXIT_FAILURE ; 
 scalar_t__ FD_ISSET (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FD_SET (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FD_ZERO (int /*<<< orphan*/ *) ; 
 int INBUF ; 
 int /*<<< orphan*/  IPPROTO_TCP ; 
 int LINEBUFSIZ ; 
 char* MSGVER ; 
 int /*<<< orphan*/  NOTELOG ; 
 int /*<<< orphan*/  NPRINTINFO (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  PRINTINFO (char*,int) ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/  SOL_SOCKET ; 
 int /*<<< orphan*/  SO_REUSEADDR ; 
 int /*<<< orphan*/  TIMEOUT ; 
 unsigned char* VERSION_CHECKER ; 
 int /*<<< orphan*/  bzero (char*,int) ; 
 int /*<<< orphan*/  close (int) ; 
 int connect (int,struct sockaddr*,int) ; 
 int debug ; 
 int /*<<< orphan*/  err (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  get_host_ip (char*) ; 
 int /*<<< orphan*/  htons (unsigned short) ; 
 int /*<<< orphan*/  memset (int /*<<< orphan*/ *,char,int) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int recv (int,char*,int,int /*<<< orphan*/ ) ; 
 int select (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,struct timeval*) ; 
 int send (int,unsigned char const*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*,int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  strlen (unsigned char const*) ; 
 int /*<<< orphan*/  strncpy (char*,char*,int) ; 
 char* strstr (char*,unsigned char const*) ; 

void             get_server_version(char *hostname,unsigned short port)
 {
   const unsigned char *version_chec = VERSION_CHECKER;
   const unsigned char *version_request = CHECKELOG;
   int          yes = 1;
   int          get_total = 0;
   int          send_total = 0;
   char         info_buf[INBUF];
   int          sock_req;
   int          ready;   
   struct sockaddr_in rem_addr;
   fd_set             read_fd;
   struct timeval     w_t;
     
     w_t.tv_sec  = TIMEOUT;
     w_t.tv_usec = 0;
     
   PRINTINFO(MSGVER,1);
 
           sock_req = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
             if(sock_req < 0) {
             perror("socket");
             exit(EXIT_FAILURE);
             }
          if(setsockopt(sock_req,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1)
          { perror("setsockopt");
          exit(1);
          }
   
           memset(&(rem_addr.sin_zero),'\0',8);
           rem_addr.sin_family = AF_INET;
           rem_addr.sin_port   = htons(port);
           rem_addr.sin_addr.s_addr = get_host_ip(hostname);            
      
               if( connect(sock_req,(struct sockaddr *)&rem_addr,sizeof(struct sockaddr)) == -1)
                { 
                err(1,NULL);
                exit(1);
                }
     
          FD_ZERO(&read_fd);
          FD_SET(sock_req,&read_fd);
          
               if ((send_total = send(sock_req,version_request,strlen(version_request),0)) == -1)
                {
                perror("send");
                exit(1);
                }
         if((ready = select(sock_req+1,&read_fd,(fd_set *)NULL,(fd_set *)NULL,&w_t)) < 0){
             perror("select");
             exit(1);
             }
         if(FD_ISSET(sock_req,&read_fd))
          {
               if( (get_total = recv(sock_req,info_buf,sizeof(info_buf)-1,0)) == -1)
                {
                perror("recv");
                exit(1);
                }
                  else if(get_total <= 0){
                  fprintf(stderr,"[-]Can not receive information\n");
                  exit(1);
                  }
          info_buf[get_total] = '\0';
          int i;
          char             linebuf[LINEBUFSIZ];
          char             lastbuf[LINEBUFSIZ];
          bzero(linebuf,sizeof(linebuf));
          bzero(lastbuf,sizeof(lastbuf));

          char *p = (char *)&linebuf[0];
          char *k = (char *)&lastbuf[0];
   
          char *z;
             if((z = strstr(info_buf,version_chec)) != NULL) 
              {
                strncpy(p,z,500);
                  for(i = 0; (*p != '-') && (*p != '\n'); i++){  
                   *k++ = *p++;
                   }
              PRINTINFO(lastbuf,debug);
              close(sock_req); 
              return; 
              }
          }
           NPRINTINFO(NOTELOG);
           close(sock_req);
           exit(1);
 }