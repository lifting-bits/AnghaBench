#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  char* ssize_t ;
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int /*<<< orphan*/  LOG_DEBUG ; 
 int /*<<< orphan*/  LOG_ERROR ; 
 int /*<<< orphan*/  LOG_WARN ; 
 char* fread (char*,int,int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  logmessage (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  pclose (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * popen (char*,char*) ; 
 int sscanf (char*,char*,uintptr_t*,...) ; 
 scalar_t__ strcmp (char*,char*) ; 
 scalar_t__ strlen (char*) ; 
 char* strstr (char*,char*) ; 
 char* strtok (char*,char*) ; 

__attribute__((used)) static int parse_fatal_error(uintptr_t *chunkptr, uintptr_t *baseaddr, uintptr_t *bssaddr, uintptr_t *libcaddr)
{
    FILE *pty;
    char *mallocerror;
    char *memorymap;
    char *line;
    char *prev;
    char message[1 << 14];
    char *anon = NULL;
    char r, w, x, s;
    ssize_t count;
    int status;
    uintptr_t mapstart;
    uintptr_t mapend;

    // Unfortunately, glibc writes it's error messaged to /dev/tty. This cannot
    // be changed in setuid programs, so this wrapper catches tty output.
    while (true) {
        // Reset any previous output.
        memset(message, 0, sizeof message);

        logmessage(LOG_DEBUG, "Attempting to invoke pseudo-pty helper (this will take a few seconds)...");

        if ((pty = popen("./pty", "r")) == NULL) {
            logmessage(LOG_ERROR, "failed to execute pseudo-pty helper utility, cannot continue");
        }

        if ((count = fread(message, 1, sizeof message, pty)) <= 0) {
            logmessage(LOG_ERROR, "failed to read output from pseudo-pty helper, %d (%m)", count, message);
        }

        logmessage(LOG_DEBUG, "Read %u bytes of output from pseudo-pty helper, parsing...", count);

        pclose(pty);

        mallocerror = strstr(message, "corrupted double-linked list");
        memorymap = strstr(message, "======= Memory map: ========");

        // Unfortunately this isn't reliable, keep trying until it works.
        if (mallocerror == NULL || memorymap == NULL) {
            logmessage(LOG_WARN, "expected output missing (this is normal), trying again...");
            continue;
        }

        logmessage(LOG_DEBUG, "pseudo-pty helper succeeded");
        break;
    }

    *baseaddr = 0;
    *chunkptr = 0;
    *bssaddr  = 0;
    *libcaddr = 0;

    logmessage(LOG_DEBUG, "attempting to parse libc fatal error message...");

    // Verify this is a message we understand.
    if (!mallocerror || !memorymap) {
        logmessage(LOG_ERROR, "unable to locate required error messages in crash dump");
    }

    // First, find the chunk pointer that malloc doesn't like
    if (sscanf(mallocerror, "corrupted double-linked list: %p ***", chunkptr) != 1) {
        logmessage(LOG_ERROR, "having trouble parsing this error message: %.20s", mallocerror);
    };

    logmessage(LOG_DEBUG, "discovered chunk pointer from `%.20s...`, => %p", mallocerror, *chunkptr);
    logmessage(LOG_DEBUG, "attempting to parse the libc maps dump...");

    // Second, parse maps.
    for (prev = line = memorymap; line = strtok(line, "\n"); prev = line, line = NULL) {
        char filename[32];

        // Reset filename.
        memset(filename, 0, sizeof filename);

        // Just ignore the banner printed by glibc.
        if (strcmp(line, "======= Memory map: ========") == 0) {
            continue;
        }

        if (sscanf(line, "%08x-%08x %c%c%c%c %*8x %*s %*u %31s", &mapstart, &mapend, &r, &w, &x, &s, filename) >= 1) {
            // Record the last seen anonymous map, in case the kernel didn't tag the heap.
            if (strlen(filename) == 0) {
                anon = line;
            }

            // If the kernel did tag the heap, then everything is easy.
            if (strcmp(filename, "[heap]") == 0) {
                logmessage(LOG_DEBUG, "successfully located first morecore chunk w/tag @%p", mapstart);
                *baseaddr = mapstart;
            }

            // If it didn't tag the heap, then we need the anonymous chunk before the stack.
            if (strcmp(filename, "[stack]") == 0 && !*baseaddr) {
                logmessage(LOG_WARN, "no [heap] tag was found, using heuristic...");
                if (sscanf(anon, "%08x-%*08x %*c%*c%*c%*c %*8x %*s %*u %31s", baseaddr, filename) < 1) {
                    logmessage(LOG_ERROR, "expected to find heap location in line `%s`, but failed", anon);
                }
                logmessage(LOG_DEBUG, "located first morecore chunk w/o tag@%p", *baseaddr);
            }

            if (strcmp(filename, "/usr/lib/libc-2.18.so") == 0 && x == 'x') {
                logmessage(LOG_DEBUG, "found libc.so mapped @%p", mapstart);
                *libcaddr = mapstart;
            }

            // Try to find libc bss.
            if (strlen(filename) == 0 && mapend - mapstart == 0x102000) {
                logmessage(LOG_DEBUG, "expecting libc.so bss to begin at %p", mapstart);
                *bssaddr = mapstart;
            }
            continue;
        }

        logmessage(LOG_ERROR, "unable to parse maps line `%s`, quiting", line);
        break;
    }

    return (*chunkptr == 0 || *baseaddr == 0 || *bssaddr == 0 || *libcaddr == 0) ? 1 : 0;
}