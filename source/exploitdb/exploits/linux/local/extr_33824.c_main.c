#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct args {char* file_path; int /*<<< orphan*/ * pipe_fd; } ;
typedef  int pid_t ;

/* Variables and functions */
 int CLONE_NEWUSER ; 
 int /*<<< orphan*/  O_RDWR ; 
 int PATH_MAX ; 
 int SIGCHLD ; 
 scalar_t__ STACK_SIZE ; 
 int /*<<< orphan*/  assert (int) ; 
 int /*<<< orphan*/  child ; 
 scalar_t__ child_stack ; 
 int clone (int /*<<< orphan*/ ,scalar_t__,int,struct args*) ; 
 int /*<<< orphan*/  close (int /*<<< orphan*/ ) ; 
 int getuid () ; 
 int open (char*,int /*<<< orphan*/ ) ; 
 int pipe (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  snprintf (char*,int,char*,long) ; 
 scalar_t__ strlen (char*) ; 
 int waitpid (int,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 scalar_t__ write (int,char*,scalar_t__) ; 

int main(int argc, char *argv[]) {
    int fd;
    pid_t pid;
    char mapping[1024];
    char map_file[PATH_MAX];
    struct args f_args;

    assert(argc == 2);

    f_args.file_path = argv[1];
    // create a pipe for synching the child and parent
    assert(pipe(f_args.pipe_fd) != -1);

    pid = clone(child, child_stack + STACK_SIZE, CLONE_NEWUSER | SIGCHLD, &f_args);
    assert(pid != -1);

    // get the current uid outside the namespace
    snprintf(mapping, 1024, "0 %d 1\n", getuid()); 

    // update uid and gid maps in the child
    snprintf(map_file, PATH_MAX, "/proc/%ld/uid_map", (long) pid);
    fd = open(map_file, O_RDWR); assert(fd != -1);

    assert(write(fd, mapping, strlen(mapping)) == strlen(mapping));
    close(f_args.pipe_fd[1]);

    assert (waitpid(pid, NULL, 0) != -1);
}