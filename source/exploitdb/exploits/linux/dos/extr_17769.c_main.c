#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct sigaction {int size; int sample_period; int read_format; int disabled; int pinned; int exclude_kernel; int exclude_hv; int wakeup_events; int /*<<< orphan*/  sample_type; int /*<<< orphan*/  config; int /*<<< orphan*/  type; int /*<<< orphan*/  sa_flags; int /*<<< orphan*/  sa_sigaction; } ;
struct perf_event_attr {int size; int sample_period; int read_format; int disabled; int pinned; int exclude_kernel; int exclude_hv; int wakeup_events; int /*<<< orphan*/  sample_type; int /*<<< orphan*/  config; int /*<<< orphan*/  type; int /*<<< orphan*/  sa_flags; int /*<<< orphan*/  sa_sigaction; } ;

/* Variables and functions */
 int /*<<< orphan*/  F_SETFL ; 
 int /*<<< orphan*/  F_SETOWN ; 
 int /*<<< orphan*/  F_SETSIG ; 
 int /*<<< orphan*/  MAP_SHARED ; 
 int O_ASYNC ; 
 int O_NONBLOCK ; 
 int O_RDWR ; 
 int /*<<< orphan*/  PERF_COUNT_SW_CPU_CLOCK ; 
 int /*<<< orphan*/  PERF_EVENT_IOC_DISABLE ; 
 int /*<<< orphan*/  PERF_EVENT_IOC_ENABLE ; 
 int /*<<< orphan*/  PERF_EVENT_IOC_RESET ; 
 int PERF_FORMAT_GROUP ; 
 int PERF_FORMAT_ID ; 
 int /*<<< orphan*/  PERF_SAMPLE_IP ; 
 int /*<<< orphan*/  PERF_TYPE_SOFTWARE ; 
 int PROT_READ ; 
 int PROT_WRITE ; 
 int /*<<< orphan*/  SA_SIGINFO ; 
 int SIGIO ; 
 int /*<<< orphan*/  close (int) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fcntl (int,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; 
 int getpid () ; 
 int /*<<< orphan*/  ioctl (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  memset (struct sigaction*,int /*<<< orphan*/ ,int) ; 
 void* mmap (int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  munmap (void*,int) ; 
 int /*<<< orphan*/  naive_matrix_multiply (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  our_handler ; 
 int perf_event_open (struct sigaction*,int /*<<< orphan*/ ,int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 scalar_t__ sigaction (int,struct sigaction*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  stderr ; 
 int total ; 

int main( int argc, char **argv ) {
	int fd;
	void *blargh;
	struct perf_event_attr pe;
	struct sigaction sa;
	memset(&sa, 0, sizeof(struct sigaction));
	sa.sa_sigaction=our_handler;
	sa.sa_flags=SA_SIGINFO;
	if (sigaction(SIGIO,&sa,NULL)<0) {
	  fprintf(stderr,"Error setting up signal handler\n");
	  exit(1);
	}
        memset(&pe,0,sizeof(struct perf_event_attr));	
	pe.type=PERF_TYPE_SOFTWARE;
	pe.size=sizeof(struct perf_event_attr);
        pe.config=PERF_COUNT_SW_CPU_CLOCK;
	pe.sample_period=100000;
	pe.sample_type=PERF_SAMPLE_IP;
	pe.read_format=PERF_FORMAT_GROUP|PERF_FORMAT_ID;
	pe.disabled=1;
	pe.pinned=1;
	pe.exclude_kernel=1;
	pe.exclude_hv=1;
	pe.wakeup_events=1;
	fd=perf_event_open(&pe,0,-1,-1,0);
	if (fd<0) {
	   printf("Error opening\n");
	}
	blargh=mmap(NULL,(1+2)*4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
	fcntl(fd,F_SETFL,O_RDWR|O_NONBLOCK|O_ASYNC);
	fcntl(fd,F_SETSIG,SIGIO);
	fcntl(fd,F_SETOWN,getpid());
	ioctl(fd,PERF_EVENT_IOC_RESET,0);
	ioctl(fd,PERF_EVENT_IOC_ENABLE,0);
	naive_matrix_multiply(0);
	ioctl(fd,PERF_EVENT_IOC_DISABLE,0);
	munmap(blargh,(1+2)*4096);
	close(fd);
	printf("Total overflows: %d\n",total);
	return 0;
}