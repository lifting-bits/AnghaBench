#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  ecx_mixedcase_ascii_decoder ; 
 scalar_t__ malloc (int) ; 
 int rand () ; 
 int /*<<< orphan*/  sprintf (char*,char*,int,int) ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 int /*<<< orphan*/  strcpy (char*,int /*<<< orphan*/ ) ; 
 int strlen (char*) ; 

char* alphaEncodeShellcode(char *shellcode, int size)
{
	int   i, input, A, B, C, D, E, F;
	char* valid_chars="0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	//first, create a big enough shellcode memory section
	char *encShellcode = (char *) malloc(sizeof((ecx_mixedcase_ascii_decoder) + (size * 2)));
	strcpy(encShellcode,ecx_mixedcase_ascii_decoder);
	char buff[4];
	int z=0;
	for(;z < size;z++)
	{
		 // encoding AB -> CD 00 EF 00
		A = (shellcode[z] & 0xf0) >> 4;
		B = (shellcode[z] & 0x0f);

		F = B;
		// E is arbitrary as long as EF is a valid character
		i = rand() % strlen(valid_chars);
		while ((valid_chars[i] & 0x0f) != F) { i = ++i % strlen(valid_chars); }
		E = valid_chars[i] >> 4;
		// normal code uses xor, unicode-proof uses ADD.
		// AB ->
		D =  0 ? (A-E) & 0x0f : (A^E);
		// C is arbitrary as long as CD is a valid character
		i = rand() % strlen(valid_chars);
		while ((valid_chars[i] & 0x0f) != D) { i = ++i % strlen(valid_chars); }
		C = valid_chars[i] >> 4;
		//edit, use curChar ptr to strncpy it.
		//printf("%c%c", (C<<4)+D, (E<<4)+F);
		sprintf(buff,"%c%c",(C<<4)+D, (E<<4)+F);
		strcat(encShellcode,buff);
	}
	return encShellcode;
}