#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct TYPE_3__ {int type; int port; int /*<<< orphan*/  buf; int /*<<< orphan*/  pio; int /*<<< orphan*/  display; int /*<<< orphan*/  ipad; } ;
typedef  TYPE_1__ rose_params ;
typedef  scalar_t__ netwib_err ;
typedef  int /*<<< orphan*/  netwib_buf ;

/* Variables and functions */
 int /*<<< orphan*/  NETWIB_ERR_ENCODETYPE_FULL ; 
 scalar_t__ NETWIB_ERR_OK ; 
 int /*<<< orphan*/  NETWIB_FALSE ; 
 int /*<<< orphan*/  NETWIB_IP_DECODETYPE_BEST ; 
 int /*<<< orphan*/  NETWIB_SPOOF_IP_INITTYPE_LINKBRAW ; 
 int NUM_DELTA ; 
 int NUM_FRAG ; 
 int NUM_LAST ; 
 int NUM_RUN ; 
#define  ROSE_TYPE_TCP 129 
#define  ROSE_TYPE_UDP 128 
 void* atoi (char*) ; 
 int /*<<< orphan*/  netwib_buf_close (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  netwib_buf_init_ext_text (char*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  netwib_buf_init_mallocdefault (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  netwib_close () ; 
 int /*<<< orphan*/  netwib_er (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  netwib_err_display (scalar_t__,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  netwib_init () ; 
 int /*<<< orphan*/  netwib_io_close (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  netwib_io_init_spoof_ip (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 scalar_t__ netwib_ip_init_buf (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 scalar_t__ rose_loop (TYPE_1__*,int,int,int,int,int) ; 

int main(int argc, char* argv[])
{
  rose_params rp;
  netwib_buf ipstr;
  netwib_err ret;
  int npack, nrew, nrun, nfrag, ndelta;

  /* initialize netwib */
  netwib_init();

  /* check parameter count */
  if (argc < 3 || argc > 9) {
    printf("Usage  : %s type(1or2) ipaddress [port] [NumP] [Numt] [NumR] [NumF] [NumD]\n", argv[0]);
    printf("Example: %s 1 1.2.3.4 80 5 9999 99999999 1021 8\n", argv[0]);
    printf(" type      : %d=tcp, %d=udp\n", ROSE_TYPE_TCP, ROSE_TYPE_UDP);
    printf(" ipaddress : address to test\n");
    printf(" port      : optional port number (0 means random)\n");
    printf(" NumP      : Number of packets to fragment\n");
    printf(" NumT      : Number of times last fragment is rewritten\n");
    printf(" NumR      : Number of times to run test\n");
    printf(" NumF      : Number of fragments per packet\n");
    printf(" NumD      : Delta between fragements.\n");
   return(1);
  }

  /* first parameter is type */
  rp.type = atoi(argv[1]);
  switch(rp.type) {
  case ROSE_TYPE_TCP :
  case ROSE_TYPE_UDP :
    break;
  default :
    printf("First parameter must be 1 or 2 (currently=%s)\n", argv[1]);
    return(2);
  }

  /* second parameter is IP address */
  netwib_er(netwib_buf_init_ext_text(argv[2], &ipstr));
  ret = netwib_ip_init_buf(&ipstr, NETWIB_IP_DECODETYPE_BEST, &rp.ipad);
  if (ret != NETWIB_ERR_OK) {
    printf("Second parameter must be an IP or hostname (currently=%s)\n",
           argv[2]);
    return(3);
  }

  /* third parameter is port number */
  rp.port = 0;
  if (argc > 3) {
    rp.port = atoi(argv[3]); /* on error, set to 0, but that's ok */
  }

  /* fourth parameter is number of packets to fragment */
  npack = 5;
  if (argc > 4) {
    npack = atoi(argv[4]); /* on error, set to 1 */
    }
  if (npack < 1) { npack = 1; }
  if (npack > 1000) { npack = 1000; }
  
  /* fifth parameter is number of times packet is rewritten */
  nrew = NUM_LAST;
  if (argc > 5) {
    nrew = atoi(argv[5]); /* on error, set to 0, but that's ok */
    }
  
  /* sixth parameter is number of times to run the test */
  nrun = NUM_RUN;
  if (argc > 6) {
    nrun = atoi(argv[6]); /* on error, set to 0, but that's ok */
    }
  
  /* seventh parameter is number of fragments per packet */
  nfrag = NUM_FRAG;
  if (argc > 7) {
    nfrag = atoi(argv[7]); 
    }
  if (nfrag < 1) { nfrag = 1; }

  /* eighth parameter is delta between fragments */
    ndelta = NUM_DELTA;
    if (argc > 8) {
      ndelta = atoi(argv[8]);
      }

  /* Make sure that the fragments do not exceed 8170 */

    nfrag = (nfrag * ndelta) + 8;
    if (nfrag > 8170) { nfrag = 8170; }
  
  printf("%s %d %s %d %d %d %d %d ndelta = %d\n\r",
          argv[0], rp.type, argv[2], rp.port, npack, nrew, nrun, 
	  nfrag / 8, ndelta);

  /* set to NETWIB_TRUE to activate display */
  rp.display = NETWIB_FALSE;

  /* instead of allocating memory each time, just use this permanent buffer */
  netwib_er(netwib_buf_init_mallocdefault(&rp.buf));

  /* initialize spoofing feature */
  netwib_er(netwib_io_init_spoof_ip(NETWIB_SPOOF_IP_INITTYPE_LINKBRAW,
                                    &rp.pio));

  /* main function */
  ret = rose_loop(&rp, npack, nrew, nrun, nfrag, ndelta);
  if (ret != NETWIB_ERR_OK) {
    netwib_er(netwib_err_display(ret, NETWIB_ERR_ENCODETYPE_FULL));
    return(ret);
  }

  /* close netwib */
  netwib_er(netwib_io_close(&rp.pio));
  netwib_er(netwib_buf_close(&rp.buf));
  netwib_close();

  return(0);
}