#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  scalar_t__ u_long ;
typedef  int u_char ;

/* Variables and functions */
 int /*<<< orphan*/  exit (int) ; 
 int /*<<< orphan*/  fputs (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  printf (char*,int) ; 
 int /*<<< orphan*/  sscanf (char*,char*,int*) ; 
 int /*<<< orphan*/  stdout ; 
 int strlen (char*) ; 

u_long check_ret_addr(char *data) { 
    u_long   ret = 0; 
    u_char   *retc; 
    int     tmp, 
            i; 

    retc = ((u_char *)&ret) + 3; 

    if((data[1] == 'x') || (data[1] == 'X')) data += 2; 

    if(strlen(data) != 8) { 
        fputs("n" 
            "Error: please use a full offset of 4 hex numbers.n" 
            "       For example: 0x12341234, 12341234, 00001234, 0x33333333 and so onn" 
            "n", stdout); 
        exit(1); 
    } 

    for(i = 0; i < 4; i++) { 
        sscanf(data, "%02x", &tmp); 
        if(tmp > 0x3f) { 
            printf("n" 
                "Error: the return address cannot contain bytes greater than 0x3f (your: 0x%02x).n" 
                "       For example 0x12341234 contains 0x12, 0x34, 0x12 and 0x34 that are ok.n" 
                "       While 0x12345678 is not ok because 0x56 and 0x78 are greater than 0x3fn" 
                "n", tmp); 
            exit(1); 
        } 
        if(tmp <= 9) { 
            *retc = tmp + 0x30; 
        } else if((tmp >= 0xa) && (tmp <= 0x23)) { 
            *retc = tmp + 0x57; 
        } else { 
            *retc = tmp + 0x1d; 
        } 
        retc--; 
        data += 2; 
    } 

    return(ret); 
}